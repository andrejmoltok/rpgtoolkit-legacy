/*
 * All contents copyright 2005, Colin James Fitzpatrick.
 * All rights reserved. You may not remove this notice.
 * Read license.txt for licensing details.
 */

%{
unsigned int g_lines = 0;

#define _END_FILE_LINE ++g_lines; CProgram::m_pLines->push_back(CProgram::m_pyyUnits->size() - 1)/**; std::cerr << "line " << g_lines << "\n"**/
%}

%%

	/* String versions of operators. */
"=="	{ return EQ; }
"->"	{ return MEM; }
"++"	{ return INC; }
"--"	{ return DEC; }
"*="	{ return MUL_ASSIGN; }
"/="	{ return DIV_ASSIGN; }
"%="	{ return MOD_ASSIGN; }
"+="	{ return ADD_ASSIGN; }
"-="	{ return SUB_ASSIGN; }
"<<="	{ return LS_ASSIGN; }
">>="	{ return RS_ASSIGN; }
"&="	{ return AND_ASSIGN; }
"|="	{ return OR_ASSIGN; }
"^="	{ return POW_ASSIGN; }
"`="	{ return XOR_ASSIGN; }
"*"		{ return MUL; }
"+"		{ return ADD; }
"-"		{ return SUB; }
"!"		{ return NOT; }
"~"		{ return BNOT; }
"/"		{ return DIV; }
"%"		{ return MOD; }
"<<"	{ return LS; }
">>"	{ return RS; }
"<="	{ return LTE; }
">="	{ return GTE; }
"<"		{ return LT; }
">"		{ return GT; }
"~="	{ return IEQ; }
"&"		{ return AND; }
"^"		{ return POW; }
"`"		{ return XOR; }
"|"		{ return OR; }
"&&"	{ return LAND; }
"and"	{ return LAND; }
"||"	{ return LOR; }
"or"	{ return LOR; }
"="		{ return ASSIGN; }
"("		{ return LPARAN; }
")"		{ return RPARAN; }
"["		{ return LARRAY; }
"]"		{ return RARRAY; }
"{"		{ return LCURL; }
"}"		{ return RCURL; }
","		{ return COMMA; }
";"		{ return SEMICOLON; }
"?"		{ return QUESTION; }
":"		{ return COLON; }
"$"		{ return LIT; }
"."		{ return DOT; }

	/* Some reserved keywords. */
[fF][oO][rR]						{ return FOR; }
[mM][eE][tT][hH][oO][dD]			{ return METHOD; }
[rR][eE][tT][uU][rR][nN]			{ return RETURN; }
[cC][lL][aA][sS][sS]				{ return CLASS; }
[sS][tT][rR][uU][cC][tT]			{ return STRUCT; }
[pP][uU][bB][lL][iI][cC]			{ return PUBLIC; }
[pP][rR][iI][vV][aA][tT][eE]		{ return PRIVATE; }
[vV][aA][rR]						{ return VAR; }
[tT][rR][uU][eE]					{ yylval = 1; return NUMBER; }
[fF][aA][lL][sS][eE]				{ yylval = 0; return NUMBER; }
[iI][nN][cC][lL][uU][dD][eE]		{ return INCLUDE; }

	/* Redirects */
[rR][eE][dD][iI][rR][eE][cC][tT]									{ return REDIRECT; }
[kK][iI][lL][lL][rR][eE][dD][iI][rR][eE][cC][tT]					{ return KILL_REDIRECT; }
[kK][iI][lL][lL][aA][lL][lL][rR][eE][dD][iI][rR][eE][cC][tT][sS]	{ return KILL_ALL_REDIRECTS; }

	/* An identifier */
~?[A-Za-z_:][A-Za-z0-9_]*	{
								char *str = _strlwr(_strdup(yytext));
								const STD_NATURAL_STRING s = str;
								free(str);

								std::map<STD_NATURAL_STRING, STACK_FRAME>::iterator i = CProgram::m_constants.find(s);
								if (i != CProgram::m_constants.end())
								{
									STACK_FRAME &cst = i->second;
									if (cst.udt & UDT_LIT)
									{
										yylval = "\"" + cst.lit + "\"";
										return STRING;
									}
									yylval = cst.num;
									return NUMBER;
								}

								yylval = s;
								return IDENTIFIER;
							}

([0-9]+(\.[0-9]+)?|([0-9]+)?(\.[0-9]+))	{ yylval = atof(yytext); return NUMBER; }
\"[^\"]*\"				{ yylval = yytext; return STRING; }

"//".*$					{ return SEMICOLON; }
\*\*.*$					{ return SEMICOLON; }
^[ \t]*\*.*$			{ return SEMICOLON; }
[ \t]+					{ }
"#"						{ }
\r\n					{ _END_FILE_LINE; return SEMICOLON; }
\r						{ _END_FILE_LINE; return SEMICOLON; }
\n						{ _END_FILE_LINE; return SEMICOLON; }

%%

int yywrap(void) { return 1; }
