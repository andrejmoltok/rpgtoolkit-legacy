///////////////////////////////////////////////////////////////////////////
//All m_contents copyright 2004, Colin James Fitzpatrick (KSNiloc)
//All rights reserved.  YOU MAY NOT REMOVE THIS NOTICE.
//Read LICENSE.txt for licensing info
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// String class (fast!)
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// Inlusions
///////////////////////////////////////////////////////////////////////////
#include "inlineString.h"		//Contains integral stuff for this file

///////////////////////////////////////////////////////////////////////////
// Resize the string (keeps current contents if possible)
///////////////////////////////////////////////////////////////////////////
void inlineString::resize(int newSize)
{
	if (newSize <= 0) newSize = 1;
	newSize++;
	if (newSize >= m_length)
	{
		//we can keep all contents
		inlineString temp(m_contents, m_length);
		delete(m_contents);
		m_contents = new(char[newSize]);
		strcmp(m_contents, (char*)temp);
	}
	else
	{
		//we can't keep all contents
		inlineString temp((char*)getChars(1, newSize), newSize);
		delete(m_contents);
		m_contents = new(char[newSize]);
		strcmp(m_contents, (char*)temp);
	}
}

///////////////////////////////////////////////////////////////////////////
// Get the length of the inlineString
///////////////////////////////////////////////////////////////////////////
int inlineString::len()
{
	//just use standard string manipulation
	return strlen(m_contents);
}

///////////////////////////////////////////////////////////////////////////
// Construct the string from an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(std::string cFrom, int length)
{
	//cast the STL string to char* and copy that memory to this string
	if (length <= 0) length = 1;
	length++;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, cFrom.c_str());
}

///////////////////////////////////////////////////////////////////////////
// Get character(s) from the inlineString
///////////////////////////////////////////////////////////////////////////
char*& inlineString::getChars(int start, int length)
{

	//check for potential error
	if ((start + length) > m_length)
	{
		//overflow
		if (start <= m_length)
		{
			//we can fix this
			length = m_length - start + 1;
		}
		else
		{
			//not fixable (starting past end of string)
			static char* toRet;
			if (toRet) delete(toRet);
			toRet = new(char[2]);
			toRet = "";
			return toRet;
		}
	}

	static char* toRet;							//string to return
	int pos = 0;								//position in string
	int chrIdx = 0;								//character index

	//if (toRet) delete(toRet);
	toRet = new(char[length + 1]);

	//set in the characters
	for (chrIdx = (start - 1); chrIdx <= ((start - 1) + (length - 1)); chrIdx++)
	{
		toRet[pos] = (unsigned char)m_contents[chrIdx];
		pos++;
	}

	//set in NULL (signals end of the string)
	toRet[pos] = NULL;

	//return the result
	return toRet;

}

///////////////////////////////////////////////////////////////////////////
// Outside interface to getChars()
///////////////////////////////////////////////////////////////////////////
char*& inlineString::mid(int start, int length) {return getChars(start, length);}
char*& inlineString::left(int length) {return getChars(1, length);}
char*& inlineString::right(int length) {return mid(len() - length, length);}

///////////////////////////////////////////////////////////////////////////
// Copy string to new memory (ideal to use as return value)
///////////////////////////////////////////////////////////////////////////
void inlineString::newMem(char* theNewMem)
{
	//Just copy over the m_contents array
	strcpy(theNewMem, m_contents);
}

///////////////////////////////////////////////////////////////////////////
// This is the class' constructor
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(int length)
{
	//Set an initial value for the inlineString
	if (length <= 0) length = 1;
	length++;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, "");
}

///////////////////////////////////////////////////////////////////////////
// This constructor sets an initial value
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(char* defaultVal, int length)
{
	//just copy the memory over
	if (length <= 0) length = 1;
	length++;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, defaultVal);
}

///////////////////////////////////////////////////////////////////////////
// Construct from a character
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(char defaultVal, int length)
{
	//just copy the memory over
	if (length <= 0) length = 1;
	length++;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, (char*)defaultVal);
}

///////////////////////////////////////////////////////////////////////////
// + another inlineString
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (inlineString &toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, (char*)toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// + a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (char* toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// + a character
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (char toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, (char*)toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// = a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (char* text)
{
	strcpy(m_contents, text);
}

///////////////////////////////////////////////////////////////////////////
// = a character
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (char text)
{
	char* createFrom = (char*)text;
	strcpy(m_contents, createFrom);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-pointer to a string
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator == (char* text)
{
	return ((strcmp(m_contents, text)) == 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-inlineString
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator == (inlineString text)
{
	return ((strcmp(m_contents, (char*)text)) == 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-STL string
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator == (std::string text)
{
	return ((strcmp(m_contents, text.c_str())) == 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-int
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator == (int text)
{
	return ((strcmp(m_contents, (char*)text)) == 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString does not contain a sub-int
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator != (int text)
{
	return ((strcmp(m_contents, (char*)text)) != 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString does not contain a sub-STL string
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator != (std::string text)
{
	return ((strcmp(m_contents, text.c_str())) != 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString does not contain a sub-pointer to a string
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator != (char* text)
{
	return ((strcmp(m_contents, text)) != 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString does not contain a sub-character
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator != (char text)
{
	return ((strcmp(m_contents, (char*)text)) != 0);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString does not contain a sub-inlineString
///////////////////////////////////////////////////////////////////////////
bool inlineString::operator != (inlineString text)
{
	return ((strcmp(m_contents, (char*)text)) != 0);
}

///////////////////////////////////////////////////////////////////////////
// Cast to char*
///////////////////////////////////////////////////////////////////////////
inlineString::operator char*()
{
	return m_contents;
}

///////////////////////////////////////////////////////////////////////////
// Cast to std::string
///////////////////////////////////////////////////////////////////////////
inlineString::operator std::string()
{
	std::string toRet = m_contents;
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// Get a binary value from the m_contents array
///////////////////////////////////////////////////////////////////////////
unsigned char& inlineString::operator [] (int pos)
{
	return (unsigned char&)m_contents[pos];
}

///////////////////////////////////////////////////////////////////////////
// + an STL string
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (std::string toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, toAdd.c_str());
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// = an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (std::string cFrom)
{
	//cast the STL string to char* and copy that memory to this string
	char* createFrom = (char*)cFrom.c_str();
	strcpy(m_contents, createFrom);
}

///////////////////////////////////////////////////////////////////////////
// += a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (char* toAdd)
{
	strcat(m_contents, toAdd);
}

///////////////////////////////////////////////////////////////////////////
// += an inlineString
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (inlineString toAdd)
{
	strcat(m_contents, (char*)toAdd);
}

///////////////////////////////////////////////////////////////////////////
// += an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (std::string toAdd)
{
	strcat(m_contents, toAdd.c_str());
}

///////////////////////////////////////////////////////////////////////////
// += a character
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (char toAdd)
{
	strcat(m_contents, (char*)toAdd);
}
