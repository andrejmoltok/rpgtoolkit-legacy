///////////////////////////////////////////////////////////////////////////
//All m_contents copyright 2004, Colin James Fitzpatrick (KSNiloc)
//All rights reserved.  YOU MAY NOT REMOVE THIS NOTICE.
//Read LICENSE.txt for licensing info
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// String class (fast!)
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// Inlusions
///////////////////////////////////////////////////////////////////////////
#include "inlineString.h"		//Contains integral stuff for this file

///////////////////////////////////////////////////////////////////////////
// Get the length of the inlineString
///////////////////////////////////////////////////////////////////////////
int inlineString::len()
{
	//just use standard string manipulation
	return strlen(m_contents);
}

///////////////////////////////////////////////////////////////////////////
// Construct the string from an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(std::string cFrom, int length)
{
	//cast the STL string to char* and copy that memory to this string
	if (length <= 0) length = 1;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, cFrom.c_str());
}

///////////////////////////////////////////////////////////////////////////
// Get character(s) from the inlineString
///////////////////////////////////////////////////////////////////////////
inlineString inlineString::mid(int start, int length)
{

	//check for potential error
	if ((start + length) > m_length)
	{
		//overflow
		if (start <= m_length)
		{
			//we can fix this
			length = m_length - start + 1;
		}
		else
		{
			//not fixable (starting past end of string)
			inlineString toRet = 1;
			return toRet;
		}
	}

	inlineString toRet(length);		//string to return
	int pos = 0;					//position in string
	int chrIdx = 0;					//character index

	//set in the characters
	for (chrIdx = (start - 1); chrIdx <= ((start - 1) + (length - 1)); chrIdx++)
	{
		toRet[pos] = (unsigned char)m_contents[chrIdx];
		pos++;
	}

	//set in the escape sequence (signals end of the string)
	toRet[pos] = (unsigned char)'/0';

	//fill in the rest with NULL
	for (chrIdx = pos; chrIdx <= len(); chrIdx++)
	{
		toRet[chrIdx] = NULL;
	}

	//return the result
	return toRet;

}

///////////////////////////////////////////////////////////////////////////
// Get characters from the left of the string
///////////////////////////////////////////////////////////////////////////
inlineString inlineString::left(int length)
{
	return mid(1, length);
}

///////////////////////////////////////////////////////////////////////////
// Get characters from the right of the string
///////////////////////////////////////////////////////////////////////////
inlineString inlineString::right(int length)
{
	return mid(len() - length, length);
}

///////////////////////////////////////////////////////////////////////////
// Copy string to new memory (ideal to use as return value)
///////////////////////////////////////////////////////////////////////////
void inlineString::newMem(char* theNewMem)
{
	//Just copy over the m_contents array
	strcpy(theNewMem, m_contents);
}

///////////////////////////////////////////////////////////////////////////
// This is the class' constructor
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(int length)
{
	//Set an initial value for the inlineString
	if (length <= 0) length = 1;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, "");
}

///////////////////////////////////////////////////////////////////////////
// This constructor sets an initial value
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(char* defaultVal, int length)
{
	//just copy the memory over
	if (length <= 0) length = 1;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, defaultVal);
}

///////////////////////////////////////////////////////////////////////////
// Construct from a character
///////////////////////////////////////////////////////////////////////////
inlineString::inlineString(char defaultVal, int length)
{
	//just copy the memory over
	if (length <= 0) length = 1;
	m_contents = new(char[length]);
	m_length = length;
	strcpy(m_contents, (char*)defaultVal);
}

///////////////////////////////////////////////////////////////////////////
// + another inlineString
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (inlineString &toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, (char*)toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// + a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (char* toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// + a character
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (char toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, (char*)toAdd);
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// = a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (char* text)
{
	strcpy(m_contents, text);
}

///////////////////////////////////////////////////////////////////////////
// = a character
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (char text)
{
	strcpy(m_contents, (char*)text);
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-pointer to a string
///////////////////////////////////////////////////////////////////////////
bool inlineString::contains(char* text)
{
	return (!(strcmp(m_contents, text)));
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-inlineString
///////////////////////////////////////////////////////////////////////////
bool inlineString::contains(inlineString text)
{
	return (!(strcmp(m_contents, (char*)text)));
}

///////////////////////////////////////////////////////////////////////////
// Determine if the inlineString contains a sub-STL string
///////////////////////////////////////////////////////////////////////////
bool inlineString::contains(std::string text)
{
	return (!(strcmp(m_contents, text.c_str())));
}

///////////////////////////////////////////////////////////////////////////
// Cast to char*
///////////////////////////////////////////////////////////////////////////
inlineString::operator char*()
{
	return m_contents;
}

///////////////////////////////////////////////////////////////////////////
// Cast to std::string
///////////////////////////////////////////////////////////////////////////
inlineString::operator std::string()
{
	std::string toRet = m_contents;
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// Get a binary value from the m_contents array
///////////////////////////////////////////////////////////////////////////
unsigned char& inlineString::operator [] (int pos)
{
	return (unsigned char&)m_contents[pos];
}

///////////////////////////////////////////////////////////////////////////
// + an STL string
///////////////////////////////////////////////////////////////////////////
inlineString& inlineString::operator + (std::string toAdd)
{
	static inlineString toRet(m_contents, m_length);
	strcat((char*)toRet, toAdd.c_str());
	return toRet;
}

///////////////////////////////////////////////////////////////////////////
// = an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::operator = (std::string cFrom)
{
	//cast the STL string to char* and copy that memory to this string
	strcpy(m_contents, cFrom.c_str());
}

///////////////////////////////////////////////////////////////////////////
// += a pointer to a string
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (char* toAdd)
{
	strcat(m_contents, toAdd);
}

///////////////////////////////////////////////////////////////////////////
// += an inlineString
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (inlineString toAdd)
{
	strcat(m_contents, (char*)toAdd);
}

///////////////////////////////////////////////////////////////////////////
// += an STL string
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (std::string toAdd)
{
	strcat(m_contents, toAdd.c_str());
}

///////////////////////////////////////////////////////////////////////////
// += a character
///////////////////////////////////////////////////////////////////////////
inlineString::operator += (char toAdd)
{
	strcat(m_contents, (char*)toAdd);
}

///////////////////////////////////////////////////////////////////////////
// Deconstructor
///////////////////////////////////////////////////////////////////////////
inlineString::~inlineString()
{
	//delete the string
	delete(m_contents);
}