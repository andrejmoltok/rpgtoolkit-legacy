<!--helpfile:RPGCodePrimer-->

<style type='text/css'> 
body, .normal { 
   font-family: verdana; 
   font-size: 10;
   text-decoration: none;  
}
.PageHeader {
   font-size: 25;
} 
.MajorHeader { 
   font-size: 20; 
} 
.MinorHeader {
   font-size: 15;
   font-weight: bold;
}
.code {
   background-color: #F9F9F9;
   font-family: courier new; 
   font-size: 11;
   color: #000DD0;
   text-decoration: none;
   border-left: 1px solid #000000;
   border-right: 1px solid #000000;
   border-top: 1px solid #000000;
   border-bottom: 1px solid #000000;
   margin-left: 10px;
   margin-right: 10px;
   margin-top: 10px;
   margin-bottom: 10px;
}
.BoxedText {
   background-color: #DDDDDD;
   border-left: 1px solid #000000;
   border-right: 1px solid #000000;
   border-top: 1px solid #000000;
   border-bottom: 1px solid #000000;
   margin-left: 10px;
   margin-right: 10px;

}
.Summary {
   background-color: #F9F9F9;
   font-size: 10;
   border-left: 1px solid #000000;
   border-right: 1px solid #000000;
   border-top: 1px solid #000000;
   border-bottom: 1px solid #000000;
   margin-left: 10px;
   margin-right: 10px;
}
a:link, a:active, a:visited {
   color: #505050;
   text-decoration: none;
}
a:hover {
   color: #B0B0B0;
   text-decoration: none;
}
</style>

<div class="PageHeader"><b>RPGCode Primer</b></div><br><br><br>

<b>INDEX:</b><br>
- <a href="#intro"><b>Introduction</b></a><br>
- <a href="#basics"><b>Basics of Programming</b></a><br>
&nbsp; &nbsp; - <a href="#basics.com">Commands</a><br>
&nbsp; &nbsp; - <a href="#basics.var">Variables</a><br>
&nbsp; &nbsp; - <a href="#basics.varmath">Variables and math</a><br>
&nbsp; &nbsp; - <a href="#basics.mwin">The Message Window</a><br>
- <a href="#flow"><b>Program Flow</b></a><br>
&nbsp; &nbsp; - <a href="#flow.if">The 'If' statement</a><br>
&nbsp; &nbsp; - <a href="#flow.else">The 'Else' statement</a><br>
&nbsp; &nbsp; - <a href="#flow.switch">The 'Switch' statement</a><br>
&nbsp; &nbsp; - <a href="#flow.op">Operators</a><br>
&nbsp; &nbsp; - <a href="#flow.pract">First practical program</a><br>
&nbsp; &nbsp; - <a href="#flow.while">While Loops</a><br>
&nbsp; &nbsp; - <a href="#flow.for">For loops</a><br>
- <a href="#multi"><b>Multitasking</b></a><br>
&nbsp; &nbsp; - <a href="#multi.thread">Threading</a><br>
- <a href="#methods"><b>Creating your own Commands</b></a><br>
&nbsp; &nbsp; - <a href="#methods.lib">Creating Libraries</a><br>
&nbsp; &nbsp; - <a href="#methods.param">Passing in Parameters</a><br>
&nbsp; &nbsp; - <a href="#methods.ret">Returning Values</a><br>
&nbsp; &nbsp; - <a href="#methods.overload">Overloading Methods</a><br>
- <a href="#adv"><b>Advanced Features</b></a><br>
&nbsp; &nbsp; - <a href="#adv.inc">Implicit Includes</a><br>
&nbsp; &nbsp; - <a href="#adv.scope">Scope</a><br>
&nbsp; &nbsp; - <a href="#adv.arrays">Arrays and Maps</a><br>
&nbsp; &nbsp; - <a href="#adv.inline">Inline Commands</a><br>
&nbsp; &nbsp; - <a href="#adv.plugins">Plugins</a><br>
&nbsp; &nbsp; - <a href="#adv.error">Error Handling</a><br>
- <a href="#struct"><b>Structures</b></a><br>
&nbsp; &nbsp; - <a href="#struct.create">Creating a Structure</a><br>
&nbsp; &nbsp; - <a href="#struct.accessor">Objects and the '-&#62;' operator</a><br>
&nbsp; &nbsp; - <a href="#struct.release">The Release() method</a><br>
- <a href="#class"><b>Classes</b></a><br>
&nbsp; &nbsp; - <a href="#class.pubpriv">'public:' and 'private:'</a><br>
&nbsp; &nbsp; - <a href="#class.methods">Methods and the '::' operator</a><br>
&nbsp; &nbsp; - <a href="#class.constructor">Constructors and Destructors</a><br>
- <a href="#spc"><b>Special topics</b></a><br>
&nbsp; &nbsp; - <a href="#spc.arrays">Arrays of Objects</a><br>
&nbsp; &nbsp; - <a href="#spc.objectswithin">Objects within Classes</a><br>
&nbsp; &nbsp; - <a href="#spc.operators">Operator overloading</a><br>
&nbsp; &nbsp; - <a href="#spc.inheritance">Class inheritance</a><br>
&nbsp; &nbsp; - <a href="#spc.reference">References and 'this'</a><br>
&nbsp; &nbsp; - <a href="#spc.virtual">Pure Virtual Methods</a><br>
- <a href="#reserved"><b>Reserved Variables</b></a><br>
&nbsp; &nbsp; - <a href="#reserved.target">Target and Source handles</a><br>

<br><br><br><br>



<a name="intro"></a>
<div class="MajorHeader">Introduction</div><br>
<div class="Normal">Hi there! As an opening note, I'd like to say that the RPGToolkit 3's RPGCode has a lot of nice new things that it didn't in versions 1 and 2. For the sake of compatability and ease of use, you can still make RPGCode programs the same way you did with version 2, though, since RPGCode has many nice new tricks, you should read through this!<br><br>

The RPGToolkit allows you to create extremely nice looking games in which your characters can walk around, fight, and do various other things. What is a game without interaction, though? A normal RPG needs more than walking around and fighting; it needs village idiots running around everywhere making smart remarks about the player, or wise men who tell the player what to do. The player also needs to be able to buy and sell items, equipment, and weapons. All of these things (and a great number more) can be accomplished easily with the RPGToolkit's built in programming language RPGCode.<br><br>

Don't run away yet! People usually see the term 'programming language' and think they'll never be able to learn. There's no need to fear, though! Even if you haven't had any programming experience in the past, the basics of RPGCode are very easy to learn! If you finish reading this and the other help files, you will be able to create programs in no time. You should start out trying to code simple things; nothing too robust! Programming only becomes real complex when you try taking on larger things (such as menu and battle systems).<br><br>

For those of you who have programming experience; you could already be half way done learning some things you need to know! RPGCode has a lot of similarities to languages like C++. With the open source development of the RPGToolkit, RPGCode is becoming more and more powerful. RPGCode is one of the most powerful languages for a 2D RPG creating tool. In fact, it is so powerful that you can create your own commands, make many different kinds of battle systems, menu systems, and even replace almost any of the built in systems with the use of RPGCode!<br><br>

You can do almost anything with RPGCode. If you want it, you can probably make it. So, let's begin learning, shall we?</div><br><br><br>



<a name="basics"></a>
<div class="MajorHeader">The Basics of Programming</div><br>
<div class="Normal">In all programming languages (including RPGCode), your computer will do many different tasks just by your typing a command. A program is nothing more than a bunch of commands that tell the computer what to do. The computer is, however, dependant on your success in giving it instructions. If you don't tell the computer when to start, what to do, and when to stop, it won't understand what you want, and certainly won't work. So lets start by learning the most simple instruction you can give the computer through RPGCode: showing text on the screen. This is done with the 'Mwin' command (mwin stands for message window).</div><br>

<div class="Code">
	Mwin("This text goes inside of a message window!")<br>
	Mwin("La la la, random messages!")</div><br>

<div class="Normal">If you run that program, you will see that the message window shows up with the text inside of it, and then disappears almost instantly. This is because you need a way to wait for the user to do something before it disappears. This is where we introduce the next command...</div><br><br><br>



<a name="basics.com"></a>
<div class="MinorHeader">Commands:</div><br>
<div class="Normal">To make the Message Window stay on the screen, you'll need to use a command called 'Wait' (Wait()). The 'Wait' command makes the computer 'pause' itself until the user presses a button on the keyboard. This is how you make the message window stay on screen using Wait:</div><br>

<div class="Code">
	Mwin("Unlike the first example,")<br>
	Mwin("this text will stay on the screen.")<br>
	Wait(a$)</div><br>

<div class="Normal">By the parentheses, you can already tell that it's a command named 'Wait'. But what does that '(a$)' mean, exactly? The parentheses (the '(' and ')') are attached to all of the commands. They hold "arguments" or "parameters" inside of them. The parameters of a command are just places where you put letters, numbers, or variables (more on this later). Some commands, however, don't take parameters (but it's always a good idea to include the parentheses anyway). 'a$' is the parameter that the wait command takes. You can also do the Wait() command another way. The example I've shown is not the prefered way to do the Wait command. This is:</div><br>

<div class="Code">
	Mwin("This example shows another way to do Wait()")<br>
	Mwin("Isn't that cool?")<br>
	a$ = Wait()</div><br>

<div class="BoxedText">If you have trouble distinguishing commands from variables, look at it this way: A command has opening and closing parentheses (the '(' and ')'), and variables have literal or numeric marks (the '$' or '!')</div><br><br><br>



<a name="basics.var"></a>
<div class="MinorHeader">Variables:</div><br>
<div class="Normal">You probably already know that computers can store information. In programming, you can store different types of information through the use of 'variables'. A variable is a label. A name you can give to certain pieces of information in a program. You can store numbers (numeric values) and words (literal values) inside of variables. If you need a clearer understanding of what variables are, think of it this way: Let's say that a variable is a cardboard box. Well, you might want to put something in that box. I'll put a big '5' in that box, and slap a label on the front of the box that says "box". The RPGCode representation of that is like this:</div><br>

<div class="Code">
	box! = 5</div><br>

<div class="Normal">Why is there a '!' after it? What does that do? That's what you call a 'numeric indicator'. What that does is tells the computer that you are storing a number in the variable. So, this is how you'd read it:<br><br>

	'box' Alright. I know that the variable is named 'box'.<br>
	'!' Now I know that we'll be storing a number in it.<br><br>

Ok, so you understand how to initiate a numeric variable. As you'll probably notice, there's something else attached to the end of the variable. '= 5'. That just means that the variable equals 5.<br><br>

Now you know how to create a variable and assign it a value. But one question remains, why does the 'a$' in the Wait command have a '$' instead of '!'? The answer is simple. As I said, the '!' is a numeric indicator, for variables that store numbers. So '$' is a literal indicator, for variables that store text. This is how you use it:</div><br>

<div class="Code">
	//Let's store the word "Hello" in box$.<br>
	box$ = "Hello"</div><br>

<div class="Normal">Hold on -- somethings different there! Why is the a line of text that has two slashes ('//') before it? Well, that's called a commented line. A commented line is just text that the programmer can write into the program so others know what's happening. Comments are ignored by the computer, and are generally good to include in your programs. It's a good idea to comment your code because you might forget what some of it does.<br><br>

Now, back to the variables. You already know that 'box$' means that it's a literal variable for storing text. Notice that "Hello" is in quotation marks. All text put into literal variables must have quotation marks around it. And just for reference later on in this help file, a literal variable is also called a "string".</div><br>

<div class="boxedtext">Remember to always use the Kill command to kill your variables, freeing up memory! If you don't, the variables will sit in memory and slow down your programs! You can find out how to use the Kill command in the command reference.<br><br>

It is also good practice to use the 'Local' command when declaring a variable. For information on this, refer to the Advanced "Scope" section of this help file.</div><br><br><br>



<a name="basics.varmath"></a>
<div class="MinorHeader">Variables and Math:</div><br>
<div class="Normal">Some of you may dislike math, but you should still read this section! It teaches you some very useful things about variables.<br><br>

In math, you can use variables to represent a number. The same is true with programming. You can also add, subtract, multiply, and devide. Again, the same is true with programming. Here is an example of multiplying a number by 2 in math (using 'x' as the variable to represent the number 10):<br><br>

	x = 10 * 2<br><br>

The end result, as you probably already know, is 20. The following is also allowed in math:<br><br>

	y = 10<br>
	x = y + 5<br><br>

And the end result would be 15 (10 + 5 = 15). The same thing can be done in programming. In RPGCode, this is how you'd do the two representations of variables:</div><br>

<div class="Code">
	//Gives x! the value 20<br>
	x! = 10*2<br><br>

	//Gives x! the value 15<br>
	y! = 10<br>
	x! = y! + 5</div><br>

<div class="Normal">Simple, eh? You can do some of the same things with literal variables that you can with numeric variables. There are limitations however, as you cannot multiply or devide from a literal variable. You can add two literal variables together the same way the add two numbers together. Here's how you do it:</div><br>

<div class="Code">
	box$ = "Jim"<br>
	box2$ = "my"<br>
	box3$ = box$ + box2$</div><br>

<div class="Normal">That puts the text "Jimmy" together in the variable 'box3'.<br><br>

Now that you know how to add and multiply in RPGCode, let's move on to subtracting and deviding. The way you subtract is exactly like adding, exept you use '-' instead of '+'. Let's take a look at some examples of subtracting and deviding:</div><br>

<div class="Code">
	//Let's subtract!<br>
	y! = 3<br>
	x! = 10 - y!<br><br>

	//Now, let's devide<br>
	x! = 10 / 2</div><br>

<div class="Normal">The above example will put the value 7 into x! because we subtracted 3 from 10 (10 - 3 = 7). The second example will put the value 5 into x! because we devided 10 by 2, making it half the full number (10 / 2 = 5).<br><br>

Congratulations! You've learned enough about variables and how to manipulate them to last you for a while. Now, I'll show you some ways of actually showing what the values of the variables are...</div><br>

<div class="boxedtext">Important note: Math calculations on variables follows the order of operations by precedence. This means that if you had a calculation like this: a! = 3-1*2, the multiplication will be evaluated before the subtraction. If you do not know the order of operations, you can use parentheses to nullify precedence. This means that the above calculation can work as needed by doing this:<br><br>

<div class="Code">
a! = (3-1) * 2</div><br>

Or a more complicated example:<br><br>

<div class="Code">
a! = 10<br>
b! = 7<br>
c! = (a!+b!) * (10 / b!)</div>
</div><br><br><br>



<a name="basics.mwin"></a>
<div class="MinorHeader">The Message Window:</div><br>
<div class="Normal">You've already learned how to show text in the message window, but you never learned how to display variables with it. Well, in this section you will. First of all, I'll introduce you to a new command. The Show() command. What it does is takes a variable and shows it's value in the message window. Here's an example of how it works:</div><br>

<div class="Code">
	x! = 5<br>
	Mwin("The value of x! is")<br>
	Show(x!)<br>
	Mwin("Cool!")<br>
	Wait()<br>
	Mwincls()</div><br>

<div class="Normal">First, I create a variable called x! and assign it the value 5. After that, I show the message "The value of x! is 5 Cool!". However, since I'm using the Show() command, the result looks like this:<br><br>

	The value of x! is<br>
	5<br>
	Cool!<br><br>

Looks a little messed up! The draw back of using Show() to show a variables value is that it will show up on a line of it's own. This is where the Mwin() command comes in handy again. You will also notice that I added in another command, Mwincls(). All that does is clears the message window from the screen.<br><br>

Here's how you would show the whole sentence on one line:</div><br>

<div class="Code">
	x! = 5<br>
	Mwin("The value of x! is &#60;x!&#62;, cool!")<br>
	Wait()<br>
	Mwincls()</div><br>

<div class="Normal">Much easier! The way you show the value of a variable with the Mwin() command is to enclose the variables name in left and right angle brackets (the &#60; and &#62;). This saves time and makes it look better.</div><br><br><br>



<a name="flow"></a>
<div class="MajorHeader">Program Flow</div><br>
<div class="Normal">All of the programs that we've made so far have run from top to bottom in perfect order. We've played with variables and shown messages, but right now they don't seem to be very useful. One of the best ways to really take control of how your program operates is program flow. With program flow, we can, instead of having the program run from top to bottom, make things stop, go back up, skip parts, or make things happen more than once.</div><br><br><br>



<a name="flow.if"></a>
<div class="MinorHeader">The "If" statement:</div><br>
<div class="Normal">One of the most used and most useful commands in all of programming is the If command. The If command allows you to do something only if something else is true. What do I mean by that exactly? Here's an example of using If in a real sentence:<br><br>

&nbsp;&nbsp; <i>If</i> I were the King of the world, <i>Then</i> I would have a pet monkey.<br><br>

Let's look at this closely. First, "If I were the King of the world". Is this statement true or false? If I am the king of the world, then it's true. And I would have a monkey for a pet. However, if I am not the king of the world, then it's false. And I would not have a monkey for a pet.<br>
As you will notice, everything after "Then" would only happen if everything before "then" was true. This is exactly how the If command works. Here's the general form of an If command:</div><br>

<div class="Code">
If(condition)<br>
{<br>
&nbsp;&nbsp; command1<br>
&nbsp;&nbsp; command2<br>
&nbsp;&nbsp; etc...<br>
}</div><br>

<div class="Normal">So what does all of that mean? Well, the If command works very similar to our everyday speech. It tests if some condition is true, and if it is true, then one or more commands gets executed. If the condition isn't true, then the commands don't get executed. It's that easy. So what is this condition that gets tested? The most basic is comparing two values. Seeing if one thing equals another. Here's an example:</div><br>

<div class="Code">
testvar! = 12<br>
If(testvar! == 12)<br>
{<br>
&nbsp;&nbsp; Mwin("Yay! The condition was true!")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
&nbsp;&nbsp; //This block of code will get executed<br>
&nbsp;&nbsp; //because testvar! is equal to 12.<br>
}<br>
If(testvar! == 0)<br>
{<br>
&nbsp;&nbsp; Mwin("testvar! was equal to 0.")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
&nbsp;&nbsp; //This block of commands will not get executed<br>
&nbsp;&nbsp; //because testvar! is NOT equal to 0. So the<br>
&nbsp;&nbsp; //commands here will be skipped.<br>
}</div><br>

<div class="Normal">In the above example, only the first block of statements is run (a block of statements are a bunch of commands enclosed in { and } brackets).  Only the first set is run because "testvar!==12" is true (testvar! is equal to 12).  Why the two equal signs? In Languages like C++, '=' is used to assign a value to a variable, whereas '==' is used to compare two values. The same is true in RPGCode.<br>
Notice that the second block doesn't get run at all. The condition "testvar!==0" is false -- testvar! is not equal to zero, so the block that follows does not get run. 
Notice also the way I indented my commands inside the blocks. This isn't necessary, but it sure looks cool, doesn't it? It just makes the code more readable.</div><br><br><br>



<a name="flow.else"></a>
<div class="MinorHeader">The 'Else' Statement:</div><br>
<div class="Normal">In the last example, you saw how two If statements were used together to check if either one or the other was true. That, however, is not the preferred way to do it. The statement "If(testvar! == 0)" is irrelevant, because if testvar! is something other than 12, then it could be any number. So, how can we fix this? Check every probable number? Well, you could. But that'd take forever, and it would be very slow. Instead, we'll use the 'Else' command to get the job done. Here's the same program again, but with the Else statement:</div><br>

<div class="Code">
testvar! = 12<br>
If(testvar! == 12)<br>
{<br>
&nbsp;&nbsp; Mwin("Yay! The condition was true!")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
&nbsp;&nbsp; //This block of code will get executed<br>
&nbsp;&nbsp; //because testvar! is equal to 12.<br>
}<br>
Else()<br>
{<br>
&nbsp;&nbsp; Mwin("testvar! wasn't equal to 12.")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
&nbsp;&nbsp; //This block of commands will not get executed<br>
&nbsp;&nbsp; //because testvar! IS equal to 12. So the<br>
&nbsp;&nbsp; //commands here will be skipped.<br>
}</div><br>

<div class="Normal">As you can see, the If and Else commands share similarity. Both contain the opening and closing braces (the { and }), and they work together. The Else command executes the block of code inside it's braces as long as the preceeding If statement is false. So, in the example above, the Else statement isn't run. The If statement, however, is.</div><br><br><br>



<a name="flow.switch"></a>
<div class="MinorHeader">The 'Switch' Statement</div><br>
<div class="Normal">In the last two program flow sections, you learned how to use conditional statements (if/else) to control the flow of certain parts of your program. In this section, you will find out how to use the 'Switch' statement. The basic form of a Switch statement looks like this:</div><br>

<div class="code">
Switch(variable) {<br>
&nbsp;&nbsp; Case(value) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; command1<br>
&nbsp;&nbsp; &nbsp;&nbsp; command2<br>
&nbsp;&nbsp; &nbsp;&nbsp; etc...<br>
&nbsp;&nbsp; }<br>
}</div><br>

<div class="Normal">As you can see, this is a bit different from the if/else commands. In this, we use Switch(variable), where variable can be either a literal or numeric value, and a Case(value) command between the Switch's brackets. Switch Cases are practically ideal for checking if a value is equal to another value. In fact - that's what it's there for.<br><br>

Switch() holds the variable that you want to check the value of. Whereas Case() compares the value of the Switch() variable to whatever is presented inside of it's parentheses (hard to understand? It'll be clearer soon!). An example of using Switch Cases might be that you have a cheat prompt in your game somewhere (say, a menu). You could check what the values are by using If statements like so:</div><br>

<div class="code">
cheat$ = Prompt("Enter a cheat:")<br>
If(cheat$ == "HEAL")<br>
{<br>
&nbsp;&nbsp; GiveHP("Frap", 100)<br>
}<br>
ElseIf(cheat$ == "I_WANT_GP")<br>
{<br>
&nbsp;&nbsp; GiveGP(10000)<br>
}<br>
ElseIf(cheat$ == "SUPER_COOL_CHARACTER")<br>
{<br>
&nbsp;&nbsp; AddPlayer("cool.tem")<br>
}<br>
Else() {<br>
&nbsp;&nbsp; Mwin("That's not a cheat!")<br>
&nbsp;&nbsp; Wait()<br>
}<br></div><br>

<div class="Normal">This, however, can get somewhat annoying, always having to type "cheat$ ==" before the actual value. Luckily, using Switch Cases, you can achieve the same affect without having to go through the whole process of using equal signs and the variable. Let's take a look at the same program using Switch Cases instead of if/else statements:</div><br>

<div class="code">
cheat$ = Prompt("Enter a cheat:")<br>
Switch(cheat$) {<br>
&nbsp;&nbsp; Case("HEAL")<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; GiveHP("Frap", 100)<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Case("I_WANT_GP")<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; GiveGP(10000)<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Case("SUPER_COOL_CHARACTER")<br>
&nbsp;&nbsp; { <br>
&nbsp;&nbsp; &nbsp;&nbsp; AddPlayer("cool.tem")<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Case(Else)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; Mwin("That's not a cheat!")<br>
&nbsp;&nbsp; &nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; }<br>
}</div><br>

<div class="Normal">There you have it - a Switch statement. Each Case() command checks to see if the variable specified in Switch() is equal to some value. This is much easier to read, and much more organized (because you can now clearly see that each Case() statement <i>belongs</i> to the Switch() statement. With If statements, you could check for random things at any time).</div><br><br><br>



<a name="flow.op"></a>
<div class="MinorHeader">Operators:</div><br>
<div class="Normal">As mentioned before, the If command can be used to do more things than just checking if two things are equal to each other. The following section lists the 'operators' you can use. Please note that only 'boolean' operators should be used for conditional statements (i.e.: the if statement). Boolean operators are operators that can evaluate to 'true' or 'false' (example: the 'equal to' operator (or '==') can be true or false, because it checks if one value is equal to another. If one is equal to the other, this evaluates to true).<br><br>

Equal To (==):<br>
Tests if two values are equal to each other. This is a boolean operator.<br>
Example:</div><br>
<div class="Code">
If(var$ == "Hello")<br>
{<br>
&nbsp;&nbsp; Mwin("Hello to you too!")<br>
}</div><br>



<div class="Normal">Not Equal To (~=):<br>
Tests if two values are NOT equal to each other. This is a boolean operator.<br>
Example:</div><br>
<div class="Code">
If(var$ ~= "Hello")<br>
{<br>
&nbsp;&nbsp; Mwin("It doesn't say hello!")<br>
}</div><br>



<div class="Normal">Addition (+=)<br>
Adds a value to a variable. This can be used for either numerical or literal variables.<br>
Example:</div><br>
<div class="Code">
x! = 1<br>
y! = 5<br>
x! += y!<br>
//Adds 5 to 1 (y to x)<br>
//This is the old way to do it: x! = x! + y!</div><br>



<div class="Normal">Subtraction (-=)<br>
Deducts a value from a variable. This can be used for either numerical or literal variables.<br>
Example:</div><br>
<div class="Code">
x! = 1<br>
y! = 5<br>
y! -= x!<br>
//Deducts 1 from 5 (x from y)<br>
//This is the old way to do it: x! = x! - y!</div><br>



<div class="Normal">Multiplied by (*=)<br>
Multiplies a value by another value. This can only be used for numerical variables.<br>
Example:</div><br>
<div class="Code">
x! = 2<br>
y! = 5<br>
x! *= y!<br>
//Multiplies x! by y!<br>
//This is the old way to do it: x! = x!*y!</div><br>



<div class="Normal">Devided by (/=)<br>
Devides a value by another value. This can only be used for numerical variables.<br>
Example:</div><br>
<div class="Code">
x! = 10<br>
y! = 2<br>
x! /= y!<br>
//Devides x! by y!<br>
//This is the old way to do it: x! = x!/y!</div><br>



<div class="Normal">Increment (++)<br>
Adds 1 to a variable. This can only be used for numerical variables.<br>
Example:</div><br>
<div class="Code">
x! = 5<br>
x!++ //Increments x! by 1<br>
//This is the old way to do it: x! = x! + 1</div><br>



<div class="Normal">Decrement (--)<br>
Deducts 1 from a variable. This can only be used for numerical variables.<br>
Example:</div><br>
<div class="Code">
x! = 5<br>
x!-- //Decrements x! by 1<br>
//This is the old way to do it: x! = x! - 1</div><br>



<div class="Normal">Exponent (^)<br>
Raises a value to the power of another value. This can only be used for numerical variables.<br>
Example:</div><br>
<div class="Code">
x! = 2<br>
Show(x! ^ 2) //Output: 4<br>
Show(x! ^ 3) //Output: 8<br>
Show(x! ^ 4) //Output: 16</div><br>



<div class="Normal">Greater Than (&#62;), Less Than (&#60;)<br>
Tests if a value is greater than another value, or if a value is less than another value. This is a boolean operator.<br>
Example:</div><br>
<div class="Code">
If(var! &#60; 5)<br>
{<br>
&nbsp;&nbsp; Show(var!)<br>
}<br>
If(var! &#62; 5)<br>
{<br>
&nbsp;&nbsp; Mwin("Too high!")<br>
}</div><br>



<div class="Normal">Greater Than Or Equal To (&#62;=), Less Than Or Equal To (&#60;=)<br>
Tests if a value is either greater than or equal to another value, or if a value is either less than or equal to another value. This is a boolean operator.<br>
Example:</div><br>
<div class="Code">
If(var! &#60;= 4)<br>
{<br>
&nbsp;&nbsp; Show(var!)<br>
}<br>
If(var! &#62;= 5)<br>
{<br>
&nbsp;&nbsp; Mwin("Too high!")<br>
}</div><br>



<div class="Normal">Logical Not (!)<br>
Tests if a value is not true. This can only be used for numeric variables, and is a boolean operator.<br>
Example</div><br>
<div class="Code">
done! = 0<br>
If(!done!)<br>
{<br>
&nbsp;&nbsp; //The ! operator before the variable checks<br>
&nbsp;&nbsp; //if done! is equal to 1 or not. If done! is<br>
&nbsp;&nbsp; //equal to 1, it evaluates to false (because 1<br>
&nbsp;&nbsp; //represents true).<br><br>

&nbsp;&nbsp; //Additionally, if you take out the logical not<br>
&nbsp;&nbsp; //operator, and leave only the variable, it checks<br>
&nbsp;&nbsp; //if done! is equal to 1.<br><br>

&nbsp;&nbsp; Mwin("done! is false!")<br>
&nbsp;&nbsp; Wait()<br>
}</div><br>



<div class="Normal">Logical AND (&&, AND)<br>
Tests if one statement AND another statement are both true. When using a Logical And, you can either use the Logical And symbol (&&) or just use the word "and". This is a 'logical' boolean operator.<br>
Example:</div><br>
<div class="Code">
//This example uses the 'logical AND' operator, '&&'<br>
If(var! == 5 && var2! &#60; 10)<br>
{<br>
&nbsp;&nbsp; //This block of code will only be executed<br>
&nbsp;&nbsp; //if var! is equal to 5 AND var2! is less than<br>
&nbsp;&nbsp; //10.<br>
&nbsp;&nbsp; Mwin("Wow, var! is 5 and var2! is less than 10!")<br>
}<br><br>

//This does the same, using the 'AND' keyword.<br>
If(var! == 5 AND var2! &#60; 10)<br>
{<br>
&nbsp;&nbsp; //This block of code will only be executed<br>
&nbsp;&nbsp; //if var! is equal to 5 AND var2! is less than<br>
&nbsp;&nbsp; //10.<br>
&nbsp;&nbsp; Mwin("Wow, var! is 5 and var2! is less than 10!")<br>
}</div><br>



<div class="Normal">Logical OR (||, OR)<br>
Tests if one statement or the other is true. When using a Logical Or, you can either use the Logical Or symbol (||) or just use the word "OR". This is a 'logical' boolean operator.<br>
Example:</div><br>
<div class="Code">
//This example uses the 'logical OR' operator, '||'<br>
If(var! == 5 || var2! &#60; 10)<br>
{<br>
&nbsp;&nbsp; //This block of code will only get executed<br>
&nbsp;&nbsp; //if var! is equal to 5 OR var2! is less than<br>
&nbsp;&nbsp; //10.<br>
&nbsp;&nbsp; Mwin("Hmm. Either var! equals 5 or var2! is less than 10.")<br>
&nbsp;&nbsp; Mwin("Either way, we still get to see this pretty block!")<br>
}<br><br>

//This does the same, using the 'OR' keyword.<br>
If(var! == 5 OR var2! &#60; 10)<br>
{<br>
&nbsp;&nbsp; //This block of code will only get executed<br>
&nbsp;&nbsp; //if var! is equal to 5 OR var2! is less than<br>
&nbsp;&nbsp; //10.<br>
&nbsp;&nbsp; Mwin("Hmm. Either var! equals 5 or var2! is less than 10.")<br>
&nbsp;&nbsp; Mwin("Either way, we still get to see this pretty block!")<br>
}</div><br><br><br>



<a name="flow.pract"></a>
<div class="MinorHeader">Your First practical program:</div><br>
<div class="Normal">Since you know how to use If's and variables, I think it's about time we make a real program. It'll just be a short, simple program to start you on your path to game making. What it will do is simple: Ask the user a question and let them decide what the answer is by pressing either 1 or 2. Let's take a look:</div><br>

<div class="Code">
//This small program will just ask the user<br>
//a question and let them select either 1<br>
//or 2.<br>
Mwin("What do you want to do?")<br>
Mwin("1 - Say something nice")<br>
Mwin("2 - Say something mean")<br><br>

result! = Wait() //This is the same as typing Wait(result!)<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //'result! = Wait()' waits for a key to be pressed<br>
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //and stores it in the variable result!.<br>
Mwincls() &nbsp; &nbsp; &nbsp; &nbsp;//Clear the window<br><br>

//Now, check to see what the user pressed...<br>
//If result! is 1, say something nice<br>
If(result! == 1)<br>
{<br>
&nbsp;&nbsp; Mwin("Hello! Aren't you looking nice today!")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
}<br><br>

//If result! is 2, say something not so nice.<br>
ElseIf(result! == 2)<br>
{<br>
&nbsp;&nbsp; Mwin("You're a dummy!")<br>
&nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; Mwincls()<br>
}<br>
</div><br>

<div class="Normal">Here's our first semi-practical program. The computer actually does something based upon what the user has done. The comments pretty much explain the program, so I won't say anything about it except for this: What happens if the user doesn't press '1' or '2'? what if they pressed 'm' by mistake? Well, both If statements would be false, and neither program block would get run. What do we do if the user does press something different? That's dealt with next...</div><br><br><br>



<a name="flow.while"></a>
<div class="MinorHeader">While Loops:</div><br>
<div class="Normal">Consider that program for a while. If the user didn't press '1' or '2', we'd want the computer to ask again until they pressed either '1' or '2'. Well, how do we do this? Just retype the same lines of code over and over until we think it's enough? That could go on forever. So instead, we'll use a 'while loop'. Before I explain what a while loop is, here's the program again with a while loop added (it will keep prompting until the user presses '1' or '2'):</div><br>

<div class="Code">
//This small program will just ask the user<br>
//a question and let them select either 1<br>
//or 2.<br><br>

//Run the While loop <i>while</i> done! is equal to 0...<br>
done! = 0<br>
While(done! == 0)<br>
{<br>
&nbsp;&nbsp; Mwin("What do you want to do?")<br>
&nbsp;&nbsp; Mwin("1 - Say something nice")<br>
&nbsp;&nbsp; Mwin("2 - Say something mean")<br><br>

&nbsp;&nbsp; result! = Wait() //This is the same as typing Wait(result!)<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //'result! = Wait()' waits for a key to be pressed<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //and stores it in the variable result!.<br>
&nbsp;&nbsp; Mwincls() &nbsp; &nbsp; &nbsp; &nbsp;//Clear the window<br><br>

&nbsp;&nbsp; //Now, check to see what the user pressed...<br>
&nbsp;&nbsp; //If result! is 1, say something nice<br>
&nbsp;&nbsp; If(result! == 1)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; Mwin("Hello! Aren't you looking nice today!")<br>
&nbsp;&nbsp; &nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; &nbsp;&nbsp; Mwincls()<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Set done! to 1. We do this so the while loop<br>
&nbsp;&nbsp; &nbsp;&nbsp; //doesn't repeat after the desired action is performed.<br>
&nbsp;&nbsp; &nbsp;&nbsp; done! = 1<br>
&nbsp;&nbsp; }<br><br>

&nbsp;&nbsp; //If result! is 2, say something not so nice.<br>
&nbsp;&nbsp; ElseIf(result! == 2)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; Mwin("You're a dummy!")<br>
&nbsp;&nbsp; &nbsp;&nbsp; Wait()<br>
&nbsp;&nbsp; &nbsp;&nbsp; Mwincls()<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Set done! to 1. We do this so the while loop<br>
&nbsp;&nbsp; &nbsp;&nbsp; //doesn't repeat after the desired action is performed.<br>
&nbsp;&nbsp; &nbsp;&nbsp; done! = 1<br>
&nbsp;&nbsp; }<br>
}<br>
</div><br>

<div class="Normal">The program is a little longer now, but more efficient. With the while loop added, if the user does not press '1' or '2', it will go back to where the while loop starts and execute the code again, waiting for the keypress. So how does the while loop work? Let's take a look...<br><br>

A While Loop is just a block of statements that gets run over and over again until a certain condition is false. In the program above, the condition that was used was like saying "While the variable 'done' equals 0, repeat this block of code". Here's the general form of a while loop:</div><br>

<div class="Code">
	While(condition)<br>
	{<br>
	   command1<br>
	   command2<br>
	   etc...<br>
	}</div><br>

<div class="Normal">Looks like the If statement, right? That's because a While loop is just like an If statement that repeats itself zero or more times. The block of code inside of the brackets (the { and }) will get executed as long as the condition is true. Once the end of the block is reached, it skips back up to the top of the While() command and tests if the condition is still true. If the condition is still true, the block will run again. Then it will skip back up to the While() statement. If the condition is true, the block will run again. The block will continue to be run over and over again as long as the condition is true. Once it is false, the commands in the block won't get run, and the program will continue along leaving the While() loop behind.<br><br>

So how do you exit a while loop? Well, you have to leave it manually. For instance, let's take a look at this piece of code:</div><br>

<div class="Code">
done! = 0<br>
While(done! == 0)<br>
{<br>
&nbsp;&nbsp; Mwin("Hi!")<br>
}</div><br>

<div class="Normal">This loop will run forever (at least until you ctrl + alt + delete out of it. Not a good idea!). You need something to exit the while loop. So how do we do that? Simply set 'done!' to equal something other than 0. Here's how you would exit the loop:</div><br>

<div class="Code">
done! = 0<br>
While(done! == 0)<br>
{<br>
&nbsp;&nbsp; Mwin("Hi!")<br>
&nbsp;&nbsp; done! = 1<br>
}</div><br>

<div class="Normal">After it prints "Hi!" to the screen, it then exits the while loop by setting done! to equal 1 instead of 0. That example, however, isn't very useful because you don't need that to repeat at all. Here's something you might want to repeat:</div><br>

<div class="Code">
count! = 1<br>
While(count! &#60;= 5)<br>
{<br>
&nbsp;&nbsp; Show(count!) //Show the value of count! in the message window<br>
&nbsp;&nbsp; count!++ //Increment done! by 1<br>
}</div><br>

<div class="Normal">This small program prints the value of count! onto the screen using the Show() command. Note that instead of setting count! to an exact number to exit the loop, I increment it by 1. This block runs until count! is less than or equal to 5. So, it prints the numbers 1 through 5 on separate lines. Then it exits the loop, resuming the program. When dealing with loops, remember to always check them and make sure that they will eventually end. If your loop doesn't end, you will have to endtask the program and shut it down. There is also a 'better form' of a While loop, which is called a For loop. That's exactly what we're learning next...</div><br><br><br>



<a name="flow.for"></a>
<div class="MinorHeader">For loops</div><br>
<div class="Normal">In a way, you've already done a For loop. Not the actual command, but a different representation. A for loop is basically a while loop that lets you initialize and increment/decrement. This is the form of a For loop:</div><br>

<div class="Code">
For(<i>initialization; condition; increment</i>)<br>
{<br>
&nbsp;&nbsp; command1<br>
&nbsp;&nbsp; command2<br>
&nbsp;&nbsp; etc...<br>
}</div><br>

<div class="Normal">Let's start with the <i>initialization</i>. Initialization just means that you create a variable to be used in the condition. For example, I could create the the variable i! and give it the value 0. That would be our base variable to use in the condition. The <i>condition</i> is the same as in a While loop and an If statement. All of the conditional operators can be used here. Next, we have <i>increment</i>. All we do here is increment or decrement the base variable. Let's take a look at an example:</div><br>

<div class="Code">
For(count! = 1; count! &#60= 5; count!++)<br>
{<br>
&nbsp;&nbsp; Show(count!)<br>
}</div><br>

<div class="Normal">If you look at the last example in the While loops section, you may notice that this does the same thing. First, it creates the variable count! and assigns it the value 1. Then, it checks if the condition is true (if count! is less than or equal to 5). If so, it runs through the loop and then increments the number. It repeats step two and step three <i>while</i> the condition is true. Where it takes three lines of code to do this with the While loop, it only takes one line with the For loop.<br><br>

The above examples output will be:<br>
1<br>
2<br>
3<br>
4<br>
5</div><br><br><br>



<a name="multi"></a>
<div class="MajorHeader">Multitasking</div><br>
<div class="Normal">Most programs you write will be programs that you set on the board using the Board Editor. However, items that are placed on the board can run multitasking programs -- that is, they can run while other programs are running at the same time. Multitasking programs work basically the same as normal programs, except for a few variations.<br><br>

A multitasking program is usually set up as an infinite loop, because it usually just makes the item walk around the screen repeatedly. In TK2, there were issues with multitasking, because you had to use the Branch() command to make the loop, and they were quite slow. You couldn't use 'real' loops like For and While because they would 'lock' up the computer (in other words, the computer would stall).<br><br>

If you're a veteran of TK2, you'll notice that TK3 makes things much easier. In the case of multitasking, you can now use For and While loops in your threads for faster, more efficient threaded programs (we'll discuss what 'thread' means in a moment). Here's an example of a simple multitasking program that makes an NPC wander around the board.</div><br>

<div class="Code">
//Makes an NPC wander around the board.<br>
isActive! = 0<br>
While(isActive! == 0)<br>
{<br>
&nbsp;&nbsp; Wander("target", 0)<br>
}</div><br><br><br>



<a name="multi.thread"></a>
<div class="MinorHeader">Threading:</div><br>
<div class="Normal">In TK2, the only way to use multitasking programs was to use them with an item placed on the board. However, TK3 is much more convenient. It allows you to use 'threads'. A 'thread' is a multitasking program that you can run from another program. So instead of going through the trouble of making an item with the multitask program and setting it on the board, you can easily type in the Thread() command to have a multitask program run. This is much more efficient and easier. Let's take a look at how you use the Thread() command:</div><br>

<div class="Code">
	id! = Thread("my_program.prg", 0)<br> 
	//Sets the multitask program "my_program.prg".<br>
	//Only runs while player is on the board.</div><br>

<div class="Normal">As the comments explain, that runs a multitasking program called 'my_program.prg'. It only runs while the player is on the board, so it will stop once the player leaves or you stop it using the ThreadSleep() command. The ThreadSleep() command puts your thread to 'sleep'. Basically, it stops your thread from running for a matter of seconds. If you want to 'wake the thread up' again, just use ThreadWake(). For information on how to use the various threading commands, look in the Command Reference.</div><br><br><br>



<a name="methods"></a>
<div class="MajorHeader">Creating your own Commands</div><br>
<div class="Normal">Since TK2, you have been allowed to create your own commands. This makes RPGCode even more expandable and extensive. Although there are 220+ commands built into the Toolkit, you may wish to create your own to make specific tasks easier. With the use of these custom commands, you can group blocks of code together and reuse them. Apart from the built in commands, there is also a library of extended commands in the file 'system.prg', demonstrating the use of creating custom commands.<br><br>

In RPGCode, you define a new command with the Method keyword. Method defines a new method. A method (or 'function', if you're familiar with C++) is basically just a command -- it works the same and looks the same. The general form of Method is:</div><br>

<div class="Code">
	Method methodname (parameter1, parameter2, ...)</div><br>

<div class="Normal">Following the Method declaration is a block of commands that tell the method what to do.<br><br>

'methodname' is the name of the method. Basically, this is what the command will be called. If you want to make a command called 'Pause', then the method name would be Pause.<br>
The list of parameters allows you send variables to the method. We won't worry about that right now.<br>
The best way to understand methods is to actually see one. Here's what I'll use as an example: There is a problem with the Wait() command. It will stop waiting for a keypress even if the user presses one of the arrow keys. This is usually ok, but when a player walks into a program, the buffer has a few more arrow presses, and the first few Waits() will be ignored. So I want to make a command that will just wait for the user to press a key, ignoring the arrow keys.  So, I'll make a method called 'Pause()':<div><br>

<div class="Code">
Method Pause()<br>
{<br>
&nbsp;&nbsp; pause_done! = 0<br>
&nbsp;&nbsp; While(pause_done! == 0)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; pause_wait$ = Wait()<br>
&nbsp;&nbsp; &nbsp;&nbsp; Switch(pause_wait$)<br>
&nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; Case("LEFT","RIGHT","UP","DOWN")<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; //Nothing happens<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; Case(Else)<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; pause_done! = 1<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; ReturnMethod(pause_wait$)<br>
&nbsp;&nbsp; Kill(pause_done!, pause_wait$)<br>
}</div><br>

<div class="Normal">And there it is! Looks a little complicated, but it really isn't. I'll go over it step by step:<br><br>

- First of all, the Method declaration tells us that the command name is Pause. It has no parameters (the empty brackets).<br> 
- Next, we set up a While loop. pause_done! is the conditional variable -- the While loop will keep running as long as pause_done! is equal to zero.<br> 
- Next, we wait for a key press.<br> 
- If the user did press an arrow key, the Wait command puts the text "UP/DOWN/LEFT/RIGHT" into the pause_wait$ variable. The Case command in the Switch statement checks if the key pressed was equal to "UP", "DOWN", "LEFT" or "RIGHT". If the key pressed was NOT one of those, pause_done! becomes equal to 1, which will break us out of the While loop.<br> 
- If the user did press an arrow, pause_done! will not be set equal to 1, and the while loop will start again, thus waiting for a key press again.<br>
- Once the While loop is done, the last command (Kill) deletes the variables created by the method. It's a good idea to Kill method variables at the end of a method to free up memory. This way, the variables won't slow things down.<br><br>

Ok, so how do you use this newly created command? Simple. Just type in it's name:</div><br>

<div class="Code">
	Pause()</div><br>

<div class="Normal">Just like a regular command. But if you were making a program, where would the method declaration go? Well, here's an example of a program which uses the Pause() command:</div><br>

<div class="Code">
	//First, let's declare the method 'Pause'<br>
	//so we can use it in the program.<br>
Method Pause()<br>
{<br>
&nbsp;&nbsp; pause_done! = 0<br>
&nbsp;&nbsp; While(pause_done! == 0)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; pause_wait$ = Wait()<br>
&nbsp;&nbsp; &nbsp;&nbsp; Switch(pause_wait$)<br>
&nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; Case("LEFT","RIGHT","UP","DOWN")<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; //Nothing happens<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; Case(Else)<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; pause_done! = 1<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; ReturnMethod(pause_wait$)<br>
&nbsp;&nbsp; Kill(pause_done!, pause_wait$)<br>
}<br><br>

	//Now, I'll show some text and use the 'Pause' command:<br>
	Mwin("Try pressing an arrow key!")<br>
	Pause() //Wait for the keypress, but ignore the arrow keys.<br>
	Mwincls()<br>
	End()</div><br>

<div class="Normal">The actual method declaration is ignored by the computer unless it is actually called. So, after the Pause() command has been executed, the program ends, because the computer ignores the entire method block. This however, is the least efficient way of using Methods. You'll learn how to make it better next...</div><br>

<div class="BoxedText">Remember: The way to use methods shown above is very inefficient. The efficient way will be explained next. However, if you do declare a method in the program you use it in, you should put the method at the top of the program. This is because the Toolkit searches through the entire program when a method is used. So, if the method is at the top of the program, the Toolkit won't have to search for it, thus speeding up your program.</div><br><br><br>



<a name="methods.lib"></a>
<div class="MinorHeader">Creating Libraries:</div><br>
<div class="Normal">As you can see, a method declaration can take up quite a bit of space in your program. Wouldn't you rather use your own methods without having to type them out every time they are to be used? Well, you can. You can do this by creating libraries.<br><br>

A method library is just a regular .prg file that simply contains method declarations for a number of commands. For example, we could put the method declaration for Pause() into a file called "pause.prg".  We can call up this library from any program using the command Include(). Here's an example of the same program but this time, the Pause() method declaration is in a file called "pause.prg":</div><br>

<div class="Code">
	Include("pause.prg") //Include the pause library<br><br>

	//Now, I'll show some text and use the 'Pause' command:<br>
	Mwin("Try pressing an arrow key!")<br>
	Pause() //Wait for the keypress, but ignore the arrow keys.<br>
	Mwincls()</div><br>

<div class="Normal">This program sure is a lot smaller and nicer looking. The Include command just opens up the file 'pause.prg' and gives you access to the methods in that file. We can then use the command Pause(), because the method declaration for Pause() is stored in 'pause.prg'.</div><br><br><br>



<a name="methods.param"></a>
<div class="MinorHeader">Passing in Parameters:</div><br>
<div class="Normal">So far we've made a method that does not have any parameters (the brackets were empty). However, usually you will want to send information to your method. This is done by passing parameters to the method. As an example, let's consider a method called Add, that just adds two numbers together:</div><br>

<div class="Code">
Method Add(add_num!, add_num2!)<br>
{<br>
&nbsp;&nbsp; add_dest! = add_num! + add_num2!<br>
&nbsp;&nbsp; ReturnMethod(add_dest!)<br><br>

&nbsp;&nbsp; //Now, we'll kill the variables to free up memory...<br>
&nbsp;&nbsp; Kill(add_num!, add_num2!)<br>
}<br><br>

//Now, let's use the new method called 'add'.<br>
Mwin("This is a demonstration of the Add method")<br>
Wait()<br>
dest! = Add(4, 1)<br>
Mwin("The result is &#60;dest!&#62;.")</div><br>

<div class="Normal">This program demonstrates how to pass in parameters to your method. The method itself is sort of useless -- it only adds two numbers together. You can do that without a method. Take a look at the command itself:</div><br>

<div class="Code">
	dest! = Add(4, 1)</div><br>

<div class="Normal">This command passes two parameters to the method: 4, 1. It also returns a value to dest! (you'll learn about returning values later). What happens with these parameters? Well, let's take a look at the method declaration:</div><br>

<div class="Code">
	Method Add(add_num!, add_num2!)</div><br>

<div class="Normal">As you can see, the parameters are variables. In a method declaration, the parameters must always be variables. The reason for that is so the user of the method can input their own values into those methods. So, when I used 4 and 1 as the values, you know that add_num! equals 4 and add_num2! equals 1. As you should notice, this is a handy way to send a method information. Also, notice my naming convention. I used the name of the method, then an underscore, then a descriptive name for each variable. I do this so that it is unquestionable that those variables in that parameter list belong to the Add method. This way, if the Add method were to call another method, the other method probably wouldn't interfere with Add's variables. It's always good programming practice to give your parameters and methods names that fit what they are supposed to do. Otherwise, you may get confused about a method and bugs may start to appear in your programs.</div><br>

<div class="boxedtext">Keep in mind: It's always good to use the Kill() command to get rid of variables that were declared inside of a method. This frees up space. However, parameter variables are automatically killed once the method ends, so you don't need to Kill() those. This is because the parameters of a method are 'scoped' directly to that method (for information on what 'scope' is, check the Advanced Features > Scope section).</div><br>

<div class="Normal">Now, look at the command I used after I added the variables together: ReturnMethod(add_dest!). This command takes the parameter add_dest! and returns the value to a variable. How do you return a value to a variable that isn't in the method declaration though? Let's discuss that...</div><br><br><br>



<a name="methods.ret"></a>
<div class="MinorHeader">Returning Values:</div><br>
<div class="Normal">If you're used to TK2's way of programming, you'll notice that some things have changed in commands. One change is the fact that you can now return values outside of commands (such as 'a$ = Wait()'). This is a more efficient way of returning values to variables because you can now clearly distinguish between normal parameters and variables that hold returned values. In the last example used, I returned a value to the variable dest!. Let's look at the command once more:</div><br>

<div class="Code">
	dest! = Add(4, 1)</div><br>

<div class="Normal">You already know that 4 and 1 are the numbers to add together. So let's learn more about returning values: To return a value to a variable, you need to use the ReturnMethod() command with the variables name as the parameter (in this case, 'add_dest!'). So when we see the line 'ReturnMethod(add_dest!)', we know that we're returning a value. The variable that you use to store the returned value and the variable that's in the method itself don't have to be the same (as you may have noticed already). So, if the parameter in the ReturnMethod() command is 'add_dest!', and the variable you use when you call the method aren't the same, it'll still work.</div><br>

<div class="BoxedText">Remember that if you are returning a value, the variable must not be in the parameter list of the method declaration. If you write the method declaration like this:<br><br>

<div class="Code">
	Method Add(add_num!, add_num2!, add_dest!)</div><br>

<div class="Normal">You can't call the method like this:</div><br>

<div class="Code">
	dest! = Add(4, 1)</div><br>

<div class="Normal">However, methods can have returned values passed back to the parameters. To do this, you must put the variable to hold the returned value in the method declaration.</div></div><br><br><br>



<a name="methods.overload"></a>
<div class="MinorHeader">Overloading Methods</div><br>
<div class="Normal">Imagine creating a method where you have parameters that you don't always need to use. Filling them in with certain values and checking if you need to use those values can get tedious (not to mention it's not efficient). Wouldn't it be ideal if you could have optional parameters in your methods, just like some of the commands have optional parameters? Of course it would! This is where method overloading comes in handy. When you overload a method, you basically recreate the method with a different parameter list, and make it do different things depending on that parameter list. Here's an example of overloading a method:</div><br>

<div class="Code">
Method Value(val$)<br>
{<br>
&nbsp;&nbsp; Show(val$)<br>
}<br><br>

Method Value(val!)<br>
{<br>
&nbsp;&nbsp; Show(val!)<br>
}<br><br>

Method Value()<br>
{<br>
&nbsp;&nbsp; Debugger("No value supplied for Value()!")<br>
}<br><br>

Value("Hello") //Shows: "Hello"<br>
Value(92) &nbsp; &nbsp;&nbsp; //Shows: 92<br>
Value() &nbsp; &nbsp; &nbsp;&nbsp; //Pops up the debugger</div><br>

<div class="Normal">As you can see, all you need to do to achieve overloading a method is giving it the same name as another method, just with different parameters. While the given example isn't very useful, you can use method overloading for many different things (another basic, but more useful example is a custom message window. You could have optional parameters for a profile image, etc.).</div><br><br><br>



<a name="adv"></a>
<div class="MajorHeader">Advanced Features</div><br>
<div class="Normal">RPGCode provides several advanced features to make your programs more powerful. These include implicit inclusion, arrays, plugins, and much more. RPGCode's advanced features can help make your programs more organized and readable, and also take your programming to a whole new level. The advanced features are described below:</div><br><br><br>



<a name="adv.inc"></a>
<div class="MinorHeader">Implicit Includes:</div><br>
<div class="Normal">You've already seen how to use the Include() command. Now, let's take it a step further with implicit inclusion. You can always type in 'Include("System.prg")' at the beginning of all of your commands that use Pause(), or you can do it efficiently. Implicit inclusion is done by typing in the name of the .prg file that you want to use methods from, followed by a period, then the method name. Here's an example of calling the 'Pause()' method from the system.prg file:</div><br>

<div class="Code">
	//This is the same as using 'include("system.prg")'<br>
	Mwin("Try pressing an arrow key!")<br>
	system.Pause() //Wait for a keypress, ignoring all arrow keys<br>
	Mwincls()</div><br><br><br>



<a name="adv.scope"></a>
<div class="MinorHeader">Scope:</div>
<div class="Normal">When you create a variable in a program, it automatically sets itself to "global scope". "Global scope" means that the variable can be accessed from any program in your game unless you Kill() it. That means that if you have a variable called 'box!' that stores the number 5 in one program, you can still access that same variable through a different program. This is because global variables stay in your computers memory until you Kill() them or your game is ended.<br><br>

So, how do you make it so that your variables aren't always global? Well, there are two commands for this specific issue: when you want to create a variable of "local scope", all you need to do is use the Local() command. "Local scope" means that the variable can only be accessed by the program that it's created in, and it will be destroyed when the program ends, freeing up memory. Here's how you use the Local() command:</div><br>

<div class="Code">
//Let's create a local variable called 'box' and<br>
//assign it the value 5...<br>
Local(box!)<br>
box! = 5<br><br>

//Now, let's show the contents of this variable...<br>
Show(box!)</div><br>

<div class="Normal">Once that program ends, the local variable 'box!' will be destroyed. If you try to access it through another program, the value will be 0 because the variable doesn't exist anymore.<br><br>

The second command you can use is AutoLocal(). This command takes it a step further by making local scope the default scope for variables. That means that <i>all</i> variables created in a program will be local, unless you use the Global() command to create a global variable.</div><br>

<div class="Code">
//Make all implicitly declared variables local...<br>
AutoLocal()<br><br>

x! = 2 //A local variable<br>
y! = 8 //Another local variable<br>
Global(z!) //A global variable</div><br>

Scope isn't restricted to "normal" variables, however. Classes and methods also have scoping rules of their own. For example, when you declare a Local() variable inside of a method, the variable is destroyed when the method ends. The same thing happens with the parameters of a method. They're destroyed when the method ends, making it easier for you (since you don't have to kill() them).</div><br><br><br>



<a name="adv.arrays"></a>
<div class="MinorHeader">Arrays and Maps:</div><br>
<div class="Normal">Beyond using variables with simple names, you can use arrays and maps. If you're familiar with other programming languages such as Java or C++, you should already know how to use an array. If that's not the case, then here's an example of using arrays:</div><br>

<div class="Code">
	var! = 5 //This is a normal variable<br>
	var[0]! = 5 //This is an array.<br>
	var[1]! = 7 //Another array.</div><br>

<div class="Normal">As you can see, arrays are distinguishable by the square brackets (the [ and ]). Inside of the square brackets, you can either use a numeric variable or a number. The number or variable inside of the brackets is called the "index". Arrays are useful for storing lots of different information about the same thing, because you can use the same variable name over and over again, just with a different index number.<br><br>

A new feature that was added into TK3 is the use of multi-dimensional arrays (sometimes referred to as multi-d arrays). Multi-dimensional arrays are the same as normal arrays, except they can hold more than one set of brackets. Here's an example of a multi-dimensional array:</div><br>

<div class="Code">
	var[0][0]! = 1<br>
	var[1][0]! = 2<br>
	var[0][1]! = 3<br>
	var[1][1]! = 4</div><br>

<div class="Normal">This example uses two sets of brackets and stores a different value for each different array. The array index 0,0 hold the value 1. The index 1,0 holds 2; 0,1 holds 3; etc.. You can even use multi-dimensional arrays to make the positioned squares of a chess board:</div><br>

<div class="Code">
For(a! = 0; a! < 7; a!++)<br>
{<br>
&nbsp;&nbsp; For(b! = 0; b! < 7; b!++)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; board[a!][b!]! = 0<br>
&nbsp;&nbsp; }<br>
}</div><br>

<div class="Normal">This example uses a For Loop to count the variable i! from 0 to 7. The value of i! is placed into the index of the array, so each index goes up to 8 (a chess board is 8 x 8 squares).<br><br>

"Maps" are the same as arrays, except their index is made of text or "strings". A simple map looks like this:</div><br>

<div class="Code">
	array[0]$ = "Hi" //This is a normal array<br>
	map[name]$ = "Bob" //This is a map</div><br>

<div class="BoxedText">Remember: Arrays always start with the index number '0'. Maps, on the other hand can have any index as long as it's text.</div><br><br><br>



<a name="adv.inline"></a>
<div class="MinorHeader">Inline Commands</div><br>
<div class="Normal">Sometimes when making programs, you want to speed up the process and in doing so, speed up the code itself. Using inline commands wherever possible is the perfect way to compliment your code with speed, efficiency, and a cool look. The addition of inline commands lets you use commands as parameters, equasions in commands which weren't possible in TK2, and other things. For example, let's say I wanted to get the length of a string and use it in the Left() command, to copy a certain amount of characters in one string to another. I could do this:</div><br>

<div class="Code">
n! = Length("Awesome")<br>
n! -= 4<br>
newString$ = Left("Awesome", n!) //Returns "awe" from "awesome"</div><br>

<div class="Normal">Or, I could do it like this, using an inline command and equasion:</div><br>

<div class="Code">
newString$ = Left("awesome", Length("awesome")-4)</div><br>

<div class="Normal">See? Using a command/equasion as the parameter, I was able to turn three lines of code into just one. How does that work, though? Well, since the Length() command returns a value, it uses the returned value from the command as the parameter, even though the returned value doesn't seem to be present. The equasion (-4) is just like typing 'n! -= 4'.<br><br>

But that isn't all you can do! Here's another example of using inline commands. This example is a somewhat useless method, as you'll find out soon enough (but you can show it to your non-programmer friends if you want to impress them). This method creates a new multi-dimensional array. Here it is without inline functions:</div><br>

<div class="Code">
Method MultiDNumArray(varName$, n!, n2!, value!)<br>
{<br>
&nbsp;&nbsp; n$ = CastLit(n!)<br>
&nbsp;&nbsp; n2$ = CastLit(n2!)<br>
&nbsp;&nbsp; temp$ = varName$ + "[" + n$ + "][" + n2$ + "]! = value!"<br>
&nbsp;&nbsp; RPGCode(temp$)<br>
&nbsp;&nbsp; Kill(varName$, n!, n2!, value!, n$, n2$, temp$)<br>
}</div><br>

<div class="Normal">It's a small method, so it won't run slow. However, it can be faster. And faster means better in the case of programming. Let's try it using inline functions:</div><br>

<div class="Code">
Method MultiDNumArray(varName$, n!, n2!, value!)<br>
{<br>
&nbsp;&nbsp; RPGCode(varName$ + "[" + CastLit(n!) + "][" + CastLit(n2!) + "]! = value!")<br>
}</div><br>

<div class="Normal">And there you have it. It's the same method with inline functions and four less lines of code.<br><br>

As you can see, using inline commands and equasions as parameters, you're making your code faster and more efficient.</div><br><br><br>



<a name="adv.plugins"></a>
<div class="MinorHeader">Plugins:</div><br>
<div class="Normal">You can create your own RPGCode commands that are embedded into the toolkit, instead of creating methods, with the use of plugins. You can write plugins for the RPGToolkit with any programming language that supports COM, but the dominating programming language to write plugins for the Toolkit in is C++. To create plugins, you need to download the plugin SDK (Software Development Kit). At the time of this writing, there are two TK3 plugin SDK's; a C++ SDK, and a VB SDK. To add a plugin into your game, simply click the project editor and select the plugins tab. From here you will be able to add and remove plugins. Once you have added the plugin to the main file, you can use the commands that you have implemented into the Toolkit.</div><br><br><br>



<a name="adv.error"></a>
<div class="MinorHeader">Error Handling:</div><br>
<div class="Normal">With most things that you will try, there will be trial and error. Well, how do you handle an error? Do you shut down? Do you continue as normal? You will eventually face this same scenario in programming. If an error occurs in your program, a debug message will appear telling you what went wrong. This can help you fix your errors. Error handling gives you a way to change what happens when an error occurs, so you can control your programs even when there's an error. This, however, is not the main purpose of error handling. It can be used for debugging purposes, but it can also be used in more abstract ways. You'll see a basic example below. So, how do we set up error handling? Listen up carefully!<br><br>

To use error handling, there are a few keywords you have to remember.</div><br>

<div class="Code">
On Error Goto :labal_name<br>
On Error Resume Next</div><br>

<div class="Normal">As you can see, these don't resemble commands at all. However, they work the same. Let's take a look at a method for checking if a file has opened and closed correctly (rather, if it exists).</div><br>

<div class="Code">
Method FileExists(file$, folder$)<br>
{<br>
&nbsp; &nbsp;//Declare the variable 'exists!'<br>
&nbsp; &nbsp;Local(exists!)<br><br>

&nbsp; &nbsp;//Assume the file exists<br>
&nbsp; &nbsp;exists! = 1<br><br>

&nbsp; &nbsp;On Error Goto :error<br><br>

&nbsp; &nbsp;//Try to open the file. If it doesn't exist,<br>
&nbsp; &nbsp;//it will cause an error.<br>
&nbsp; &nbsp;OpenFileInput(file$, folder$)<br><br>

&nbsp; &nbsp;//Close the file just incase it was opened, but<br>
&nbsp; &nbsp;//don't trigger another error.<br>
&nbsp; &nbsp;On Error Resume Next<br>
&nbsp; &nbsp;CloseFile(file$)<br><br>

&nbsp; &nbsp;//Return the result<br>
&nbsp; &nbsp;ReturnMethod(exists!)<br><br>

&nbsp; &nbsp;//End the method so the error handler isn't run<br>
&nbsp; &nbsp;End()<br><br>

:error<br>
&nbsp; &nbsp;//If we get here, there was an error<br>
&nbsp; &nbsp;exists! = 0<br>
&nbsp; &nbsp;Resume Next<br>
}</div><br>

<div class="Normal">Looks a little confusing, right? Don't worry, it's quite easy once you get the hang of it. Let's take a look at what it does line by line.<br><br>

<b>On Error Goto :error</b> - This sets up your error handling. If there is an error on any line of code after this, it will branch to the label ':error'.<br>
<b>Local(exists!) / exists! = 1</b> - Creates a local variable. 1 will be returned if there was no error.<br>
<b>OpenFileInput(file$, folder$)</b> - This opens the file. If there was an error opening the file, the method will automatically branch to the :error label.<br>
<b>On Error Resume Next</b> - By using this, we are saying that if we run into an error after this line, don't do anything about it and resume the next line of code as if there was no error.<br>
<b>ReturnMethod(exists!)</b> - Now, we return the value of open!. If there was an error, we branched to :error, changed exists! to 0, and then we used 'Resume Next'. Resume Next takes us back to the next line of code after the the line with the error (which is the ReturnMethod line. So we return the value 0, which means it failed).<br>
<b>End()</b> - Ends the method and takes us back to the main program.<br><br>

If you want, you can pop up the debug message window and give an error by using the Debugger() command. For information on how to use the debugger command, check the TK3 command reference.</div><br>

<div class="boxedtext">When using error handling, make sure you only branch to a label inside of the method you're using. Never branch to an outside label (this will mess up your programs!) Also, do not indent your labels. They will not work if you do.</div><br><br><br>



<a name="struct"></a>
<div class="MajorHeader">Structures</div><br>
<div class="Normal">Since programs can get complicated and a little out of hand sometimes, you may want some way to organize your variables - your programs data. Using structures allows you to do just that. It's a good solution for keeping track of data that may otherwise be a hassle. For instance, say you have a large program that uses many different variables. Well, it's going to be quite a job making sure you Kill() them all. What if you could do it in one fell swoop? In this section, we'll cover the basics of using structures and objects to manipulate and organize your programs.</div><br><br><br>



<a name="struct.create"></a>
<div class="MinorHeader">Creating a Structure</div><br>
<div class="Normal">Structures are simple enough to create. You use the 'Struct' command, followed by the structure name, then an opening and closing bracket (the same way you declare a method). In RPGCode, it looks like this:</div><br>

<div class="Code">
struct <i>structName</i><br>
{<br>
&nbsp;&nbsp; <i>data</i><br>
}</div><br>

<div class="Normal">Simple, right? Now, let's put some data into it. We'll create a Cat structure, which will contain data for the cats age, weight, and name. It's not much, but it will help you learn the basics.</div><br>

<div class="Code">
//Create a new structure called 'Cat'<br>
struct Cat<br>
{<br>
&nbsp;&nbsp; age! &nbsp; &nbsp;//The cats age<br>
&nbsp;&nbsp; weight! //The cats weight<br>
&nbsp;&nbsp; name$ &nbsp; //The cats name<br>
}</div><br><br><br>



<a name="struct.accessor"></a>
<div class="MinorHeader">Objects and the '-&#62;' operator</div><br>
<div class="Normal">Now, notice that the variables are not set to any initial value. You can't initialize a variable with a value inside the structure. So, how do you do it? Assigning values to the variables from outside of the structure won't assign the values to the variables in the structure. Instead, it will just recreate the variables outside of the structure (confusing? It won't be soon). You assign values to the structure variables by creating an "Object". Objects allow you to access the data inside of the structure. You create an object by typing a name for the object, then an equals sign, then the structure name. This is how it's done:</div><br>

<div class="Code">
//Create the Cat structure...<br>
struct Cat<br>
{<br>
&nbsp;&nbsp; age!<br>
&nbsp;&nbsp; weight!<br>
&nbsp;&nbsp; name$<br>
}<br><br>

//Create a new object for the structure<br>
SomeCat = Cat()</div><br>

<div class="Normal">Now we have our object. Note that objects do not use a ! or $ like variables do. Let's move on to assigning values. To access the data in a structure, you use the Object, followed by a '-&#62;', and then the variable. Hold on, though; what <i>is</i> a '-&#62;'? This is an operator used for accessing a structures data. You use the accessor operator whenever you want to retrieve or change data in a structure. Let's try changing some of that data...</div><br>

<div class="Code">
//Set the cats age, weight, and name...<br>
SomeCat -> age! = 1<br>
SomeCat -> weight! = 5<br>
SomeCat -> name$ = "Bob"<br><br>

//Let's tell the world the cats name<br>
Show(SomeCat->name$)</div><br>

<div class="Normal">If you run that, you'll see that the variables have, in fact, been assigned values.</div><br><br><br>



<a name="struct.release"></a>
<div class="MinorHeader">The Release() method</div><br>
<div class="Normal">Have you ever had a party, and were left with the clean-up job? If it was a big party, it can be a big mess to clean up. The same is true with programming. If you make a program that uses a lot of variables, you're going to have to clean them up sometime. As previously stated, this can be a hassle. Structures not only give you a more organized look, but make clean up a lot easier. Instead of running through the whole Kill() process, you can use a method that makes your life easier - Release().<br><br>

When you call Release(), it kills off all of the data in the structure (which is efficient. You can even use structures for simple programs that may just use a lot of variables, as it makes things easier to track, organize, and clean up). You use Release() the same way you change the value of a variable; through the accessor:</div><br>

<div class="Code">
SomeStruct->Release() //Kill the data</div><br>

<div class="Normal">Please note that all structures (and classes, discussed next) have this method. You don't (and shouldn't) need to code it yourself.<br><br>



<a name="class"></a>
<div class="MajorHeader">Classes</div><br>
<div class="Normal">You may want to have more control over data than you have with structures. Perhaps you want to have data that can only be manipulated by accessing a method - 'safe' data, in a sense - or you want to use methods in general, which you can't with structures. In this section, you're going to learn what a class is, and some of the many things you can do with it. Let's take a look at the Class syntax:</div><br>

<div class="Code">
class <i>ClassName</i><br>
{<br>
&nbsp;&nbsp; <i>Scope:</i><br>
&nbsp;&nbsp; &nbsp;&nbsp; <i>data</i><br>
}</div><br><br><br>



<a name="class.pubpriv"></a>
<div class="MinorHeader">'public:' and 'private:'</div><br>
<div class="Normal">It looks like a struct with a different name, right? Well, notice that it says '<i>Scope:</i>'. Where it says 'scope', you place either a 'public:' or 'private:' keyword. What does that do, though? If you read the 'scope' section of this file, you'll know that scope controls where data can be read (essentially). Local scope means that locally created variables will be destroyed when the program ends. Global scope means that globally created variables will be destroyed when you use the Kill() command, and can be accessed in any program until you do. Public and Private scope is reserved for classes. 'public' scope can be thought of a classes global scope. When variables are declared after the 'public:' keyword is used, you can access the variable and assign a value to it the same way you would with a structure (by using the accessor operator). If you declare a variable in 'private' scope, you have to use a method if you want to return or manipulate the variable. Here's an example of declaring and using data publically and privately:</div><br>

<div class="Code">
class CPerson<br>
{<br>
&nbsp;&nbsp; public:<br>
&nbsp;&nbsp; &nbsp;&nbsp; name$<br><br>

&nbsp;&nbsp; private:<br>
&nbsp;&nbsp; &nbsp;&nbsp; age!<br>
&nbsp;&nbsp; &nbsp;&nbsp; height!<br>
&nbsp;&nbsp; &nbsp;&nbsp; weight!<br>
}<br><br>

Bob = CPerson()<br><br>

Bob -> name$ = "Bob" //This will work.<br>
Bob -> age! = 32 //This won't work!<br>
Bob -> Release()</div><br>

<div class="Normal">As you can see, I first declared the class named 'CPerson'. Then, I declared the variable 'name$' as public scope, and the variables age!, height!, and weight! as private scope. I created the object (called Bob), and assigned "Bob" to name$. Since name$ was declared under public scope, it will set the variable accordingly. Next I assigned the value 32 to age!, which was created privately. age! will not equal 32. How will we change privately scoped data? That's next. First, however, a technical note;</div><br>

<div class="BoxedText">Even though name$ was declared publically, member data (variables) should never be placed in public scope. This defeats one of the goals of a class; to hide the class' data from the user. The data should be hidden because the user of the class does not need to know how the class implements (uses) the data. If the user of the class only needs to worry about how to use the class' methods, it makes the class much easier to use. If, instead, the user needs to worry about setting attributes to the variables themselves, the class is harder to use, and is more prone to cause errors.</div><br><br><br>



<a name="class.methods"></a>
<div class="MinorHeader">Methods and the '::' operator</div><br>
<div class="Normal">As previously stated, you can't change private data by trying to access it directly. You must use a method. Methods in a class can be handled two ways. For smaller methods (usually ones that just return a private variable), you can declare the method normally inside the class. The other way takes a bit more than just declaration for a class. You have to first make a "prototype" of the method. This is done by declaring the method inside of the class in public scope, then "defining" it outside of the class. The difference between delcaration and definition is that, with declaration, all you do is write 'Method' followed by the method name, and parameters. Definition is where you actually write what the method will do (though 'declaration' has been used instead of 'definition' up to this point in the document). When defining a class' method (also known as a "member method", becuase it's a member of the class), the syntax is as follows:</div><br>

<div class="Code">
Method <i>ClassName</i>::<i>MethodName</i>(<i>parameters...</i>)</div><br>

<div class="Normal">If you're used to making methods, you should already know the significance of the last parts of that piece of code. However, you probably haven't seen it used this way. First, we start with specifying that it's a method. Then, we write the name of the class, followed by the '::' operator, then the name of the method, and parameters. The '::' (or 'Scope Resolution') operator tells us that the method belongs to a class (as specified by the preceding Class Name). Here's an example:</div><br>

<div class="Code">
class CPerson<br>
{<br>
&nbsp;&nbsp; public:<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method SetName(name$)<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetName()<br><br>

&nbsp;&nbsp; private:<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Name$<br>
}<br><br>

//Now, define the member methods...<br>
Method CPerson::SetName(name$)<br>
{<br>
&nbsp;&nbsp; //Set m_Name$ to the given value.<br>
&nbsp;&nbsp; m_Name$ = name$<br>
}<br><br>

Method CPerson::GetName()<br>
{<br>
&nbsp;&nbsp; //Return the contents of m_Name$ to the user...<br>
&nbsp;&nbsp; ReturnMethod(m_Name$)<br>
}<br><br>

//Creating a new object for CPerson,<br>
//called 'Bob'...<br>
Bob = CPerson()<br><br>

Bob -> SetName("Bob") &nbsp;//Set the CPersons name to Bob<br>
name$ = Bob->GetName() //Return the CPersons name to name$<br>
Show(name$)<br>
Bob -> Release() &nbsp; &nbsp; &nbsp; //Kill all the class data...</div><br>

<div class="Normal">And there you have it. Both the SetName() and GetName() methods are declared in public scope, and then defined outside of the class. You access them the same way you access a variable. While on the subject of methods, they can take objects as parameters. To make a method accept an object as a parameter, you type the class name (which is the 'data type'), followed by an object name. Here's an example:</div><br>

<div class="Code">
Method CallSetName(CPerson object!, name$)<br>
{<br>
&nbsp;&nbsp; //Use the SetName() method from a class.<br>
&nbsp;&nbsp; object->SetName(name$)<br>
}<br><br>

Bob = CPerson()<br><br>

CallSetName(Bob, "Bob") //Call SetName() from Bob (CPerson)<br>
Show(Bob->GetName()) //Show the name "Bob".</div><br>

<div class="Normal">See? Pretty easy. I created the CallSetName method with two parameters; object! and name$. object! is, of course, the object to call SetName() from. It's also of type CPerson, so if you put in an object of type Cat, it would give you an error. But why is there a ! after it? When you use the !, it passes the actual object into the method. Not having the ! makes a copy of the object and uses that. name$ is the name to use as SetName()'s parameter. While this is a useless example, you get the idea.</div><br><br><br>



<a name="class.constructor"></a>
<div class="MinorHeader">Constructors and Destructors</div><br>
<div class="Normal">So far, you've learned how to create a class, the difference between private and public scope, and member methods. Now we'll learn about constructors and destructors. In short, constructors are for allocating memory, and destructors are for deallocating memory. In less confusing terms, constructors and destructors are member methods that are called right when you create an object for a class, and right when you use Release().<br><br>

Well, what's the use of constructors and destructors if they are just member methods? Constructors are for initialization. They allow you to set values for private data in the class, or anything else you need to do (i.e.: instead of using a SetName() method, it's much easier to do it with a constructor). Destructors are useful for the reverse reason; instead of initializing things, you can destroy data.<br><br>

Calling a constructor is taken care of when you create an object with the New() command. You can pass parameters to the constructor if you need to, and set values for those with the New() command. How would you do that, though? Doesn't the New() command take one parameter? Initially, yes. However, if you have a constructor with parameters, it takes as many as needed. Here's an example of our CPerson class using a constructor to set an initial name.</div><br>

<div class="Code">
//Create the CPerson class<br>
class CPerson<br>
{<br>
&nbsp;&nbsp; public:<br>
&nbsp;&nbsp; &nbsp;&nbsp; //Create a constructor and destructor...<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method CPerson(name$) //CPerson constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method ~CPerson() &nbsp; &nbsp; //CPerson destructor<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; Method GetName()<br><br>

&nbsp;&nbsp; private:<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Name$<br>
}<br><br>

//Create the constructor method...<br>
Method CPerson::CPerson(name$)<br>
{<br>
&nbsp;&nbsp; m_Name$ = name$<br>
}<br><br>

//Create the destructor method...<br>
Method CPerson::~CPerson() {}<br><br>

//Now, the GetName() method...<br>
Method CPerson::GetName()<br>
{<br>
&nbsp;&nbsp; ReturnMethod(m_Name$)<br>
}<br><br>

//Now, create an Object for CPerson, calling the<br>
//constructor...<br>
Bob = CPerson("Bob")<br><br>

Show(Bob->GetName()) //Show "Bob"<br>
Wait()<br><br>

//Now, Release() the data (this calls the<br>
//destructor.<br>
Bob -> Release()</div><br>

<div class="Normal">Nothing really different about a constructor and a member method. It takes name$ as it's parameter, and works the same way as the SetName() method did. This, however, is more efficient, since you can call it when creating the object (notice the extra parameter, "Bob", used with the New() command). You should also note that the constructor has the same name as the class itself. This is necessary. Both the constructor and destructor have the same name as the class.<br><br>

Moving on, you'll see that the destructor takes no parameters, and does nothing. Well, if it does nothing, why keep it there? Simply put, it was there as an example (later, you'll see a destructor that does something). It also has a '~' (or 'tilde') before the destructor name. The ~ distinguishes the method as a destructor.</div><br><br><br>



<a name="spc"></a>
<div class="MajorHeader">Special topics</div><br>
<div class="Normal">Now that you've learned some of the main features of classes and structures, let's focus a little bit more on "special" topics. In the next few sections, you'll learn how to manipulate objects, use inheritance, and other neat things. Also, be sure to read all of the technical notes that occasionally appear in the next few sections, as they give good tips and goals of Object-Oriented Programming (OOP).</div><br><br><br>



<a name="spc.arrays"></a>
<div class="MinorHeader">Arrays of Objects</div><br>
<div class="Normal">Sometimes, you might want to use the same class or structure multiple times with different attributes in the same program. You can do this by creating multiple objects to the class or structure with different object names, but that's not very efficient. The best way to approach this is by using an array as an object (if you don't know what arrays are, read the 'Arrays and Maps' sub-section of the Advanced Features section). Using an array object is like having multiple objects of the same name (each having it's own index number), that access the same class or structure with different attributes. Let's say you wanted to make a litter of cats. Each one has unique attributes, but they all come from the same source (the cat class). Example:</div><br>

<div class="Code">
class Cat<br>
{<br>
&nbsp;&nbsp; public:<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method Cat(age!) //Constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method ~Cat() &nbsp;&nbsp; //Destructor<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; Method SetName(name$) { m_Name$ = name$ }<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetName() { ReturnMethod(m_Name$) }<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetAge() { ReturnMethod(m_Age!) }<br><br>

&nbsp;&nbsp; private:<br>

&nbsp;&nbsp; &nbsp;&nbsp; //The cats attributes...<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Name$<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Age!<br>
}<br><br>

/////////////////////////////<br>
// Destructor<br>
/////////////////////////////<br>
Method Cat::~Cat() {}<br><br>

/////////////////////////////<br>
// Constructor<br>
/////////////////////////////<br>
Method Cat::Cat(age!)<br>
{<br>
&nbsp;&nbsp; m_Age! = age!<br>
}<br><br>

//Now, create an array object for the cats...<br>
For(i! = 0; i! < 5; i!++)<br>
{<br>
&nbsp;&nbsp; Litter[i!] = Cat(1)<br>
}<br><br>

Litter[3]->SetName("Charlie")<br>
Show(Litter[3]->GetName())<br>
Show(Litter[0]->GetAge())<br>
Wait()<br><br>

For(i! = 0; i! < 5; i!++)<br>
{<br>
&nbsp;&nbsp; //Clean up the data...<br>
&nbsp;&nbsp; Litter[i!] -> Release()<br>
}</div><br>

<div class="Normal">And there you have it. If you already know how to use an array, you won't have any trouble getting used to array objects. Just remember that, like all objects, you don't use any variable operators attached to it's name (! and $).</div><br>

<div class="BoxedText">As a side note; They're referred to as "objects" because, like real objects, they have attributes (variables) and behavior (methods). The behavior, or methods, of a class can affect how the attributes are used. Just as the behavior of a car includes starting up, moving, and stopping. And some of it's attributes are color, year, and model. One of the goals of object-oriented programming and design is thinking about your programs as real-life situations, problems, etc. We use objects in everyday life for various reasons, and we should think of objects in programming no differently.</div><br><br><br>



<a name="spc.objectswithin"></a>
<div class="MinorHeader">Objects within Classes</div><br>
<div class="Normal">Classes can take normal data (literal and numeric variables, and arrays), and they can also take Objects. This allows you to access a class within a class, or even a structure within a class. This can be very useful. Let's say you wanted to access a litter of cats from a 'base' cat class. All you need to do is put the object name in public scope, and initialize the object with the constructor (and Release() it in the destructor). Here's an example:</div><br>

<div class="Code">
struct Kitten<br>
{<br>
&nbsp;&nbsp; //Kitten information...<br>
&nbsp;&nbsp; name$<br>
}<br><br>

class CCat<br>
{<br>
&nbsp;&nbsp; public:<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method CCat() //Cat constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method ~CCat() //Cat destructor<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; Litter[2] //The array object for the Kitten struct<br><br>
}<br><br>

Method CCat::CCat()<br>
{<br>
&nbsp;&nbsp; //Create the new object for the Kittens<br>
&nbsp;&nbsp; Litter[0] = Kitten()<br>
&nbsp;&nbsp; Litter[1] = Kitten()<br>
}<br><br>

Method CCat::~CCat()<br>
{<br>
&nbsp;&nbsp; //Kill off the data for the Litter[] object...<br>
&nbsp;&nbsp; For(i! = 0; i! < 2; i!++)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; Litter[i!] -> Release()<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Kill(i!)<br>
}<br><br>

//Now, create an object for the cat class...<br>
Cat = CCat()<br><br>

//Name the kitten...<br>
Cat->Litter[0]->name$ = "Bill"<br>
Show(Cat->Litter[0]->name$)<br>
Wait()<br><br>

//Now, call the CCat destructor. The CCat<br>
//destructor also calls Release() for the<br>
//Litter object.<br>
Cat -> Release()</div><br><br><br>



<a name="spc.operators"></a>
<div class="MinorHeader">Operator Overloading</div><br>
<div class="Normal">From time to time, you'll want to reassign something to an object. Or, perhaps, you'll want to add something to an object. This is where operator overloading comes in handy. Operator overloading allows you to define how operators like '=', '+', and '-=' will work, corresponding with your class. Well, why do we need operator overloading? Can't you just reassign the object the class again, with new values (i.e.: 'Guy = CPerson()')? The answer is yes, you can. However, it is a very bad idea. If you do that, it will reassign the object, but the instance of the previous object is still there, causing a memory leak.<br><br>

Let's overload the = (equals) operator for a small string class:</div><br>

<div class="Code">
////////////////////////////////////<br>
// String class declaration<br>
////////////////////////////////////<br>
class String<br>
{<br>
&nbsp;&nbsp; public:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method String(newString$)<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Member methods<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method Value() { ReturnMethod(m_String$) }<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Overloaded operators<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator=(String newString)<br><br>

&nbsp;&nbsp; private:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Helper data<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_String$<br>
}<br><br>

////////////////////////////////////<br>
// Constructor<br>
////////////////////////////////////<br>
Method String::String(newString$)<br>
{<br>
&nbsp;&nbsp; //Set the string<br>
&nbsp;&nbsp; m_String$ = newString$<br>
}<br><br>

////////////////////////////////////<br>
// Operator =<br>
////////////////////////////////////<br>
Method String::operator=(newString)<br>
{<br>
&nbsp;&nbsp; //Copy the other objects data into this one<br>
&nbsp;&nbsp; m_String$ = newString->Value()<br>
}<br><br>

//Create the objects and assign one<br>
//to the other...<br>
Str = String("String 1")<br>
Show(Str->Value()) //Show "String 1"<br><br>

Str2 = String("String 2")<br>
Str = Str2$<br>
Str2->Release()</div><br>

<div class="Normal">As you can see from the class declaration, there's a method named 'operator='. When overloading an operator, you use a method named 'operator', followed by the operator you want to overload (in this case, the equals operator). Most operators can be overloaded (all except '->' and '.'). The method operator= takes one parameter; newString. newString is an object, which should be of type String (String being the class).<br><br>

Next, you'll notice the definition of operator=. All we do here is put the contents of newString into m_string$.<br><br>

Finally, we create two new instances of the String class (Str and Str2). On the second to last line of code, you'll notice that there's a literal indicator (or operator) after Str2. Why is that? Well, the object, Str2, has no literal value to return (Str2$, however, does).<br><br>

It would be much more idealistic if we could use objects where literal, or even numerical variables can be used. This is where the overloaded $ and ! come in. Let's add one more operator to the class -- the $ operator.</div><br>

<div class="Code">
////////////////////////////////////<br>
// String class declaration<br>
////////////////////////////////////<br>
class String<br>
{<br>
&nbsp;&nbsp; public:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method String(newString$)<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Overloaded operators<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator=(String newString)<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator$()<br><br>

&nbsp;&nbsp; private:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Helper data<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_String$<br>
}<br><br>

////////////////////////////////////<br>
// Constructor<br>
////////////////////////////////////<br>
Method String::String(newString$)<br>
{<br>
&nbsp;&nbsp; //Set the string<br>
&nbsp;&nbsp; m_String$ = newString$<br>
}<br><br>

////////////////////////////////////<br>
// Operator =<br>
////////////////////////////////////<br>
Method String::operator=(String newString)<br>
{<br>
&nbsp;&nbsp; //Copy the other objects data into this one<br>
&nbsp;&nbsp; m_String$ = newString<br>
}<br><br>

////////////////////////////////////<br>
// Operator $<br>
////////////////////////////////////<br>
Method String::operator$()<br>
{<br>
&nbsp;&nbsp; //Return 'm_String$'<br>
&nbsp;&nbsp; ReturnMethod(m_String$)<br>
}<br><br>

//Create the object...<br>
Str = String("A string")<br>
Show(Str) //Show "A string"</div><br>

<div class="Normal">As you probably noticed, overloading the $ operator is fairly simple. For either the ! or $ operators, the minimum you need to do is return a value. This value is then used when supplying an object where you would normally use a variable. In this case, we are able to use Str as the parameter in Show(). Also notice that there is no more Value() method. It's not needed anymore, thanks to operator$.</div><br><br><br>



<a name="spc.inheritance"></a>
<div class="MinorHeader">Class inheritance</div><br>
<div class="Normal">Sometimes, you may take two classes and want to combine them. This can be a daunting task (also an inefficient one). Instead of combining classes, one can act as a base class for the other. This is class inheritance - a relationship between classes. When one class inherits another, it inherits the classes methods and data. The class that inherits another class is called the 'derived' class, and the class being inherit from is called the 'base' class. Here's an example of inheritance:</div><br>

<div class="code">
class <i>DerivedClass</i>: <i>BaseClass, BaseClass2, etc...</i><br>
{<br>
&nbsp;&nbsp; <i>Scope:</i><br>
&nbsp;&nbsp; &nbsp;&nbsp; <i>data</i><br>
}</div><br>

<div class="Normal">As you can see, this is a normal class declaration, with the exception of a colon (':') and the base class names. You can have either one or multiple base classes to derive from. If the derived class has methods or data of the same name as ones in the base class(es), the derived class will 'override' the base classes data. It does this so you won't call the different methods or data accidentally.<br><br>

Here's an example of inheritance:</div><br>

<div class="Code">
//////////////////////////////////////<br>
// CInteger class declaration<br>
//////////////////////////////////////<br>
class CInteger<br>
{<br>
&nbsp;&nbsp; public:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method CInteger(int!) { m_Int! = int! }<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Overloaded operators<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator!() { ReturnMethod(m_Int!) }<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator=(CInteger newVal)<br><br>

&nbsp;&nbsp; private:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Helper data<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Int!<br>
}<br><br>

//CInteger operator=<br>
Method CInteger::operator=(CInteger newVal)<br>
{<br>
&nbsp;&nbsp; //It's an object<br>
&nbsp;&nbsp; m_Int! = newVal<br>
}<br><br>


//////////////////////////////////////<br>
// CFraction class declaration<br>
//////////////////////////////////////<br>
class CFraction: CInteger<br>
{<br>
&nbsp;&nbsp; public:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Constructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method CFraction(top!, bottom!)<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Member methods<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetTop() { ReturnMethod(m_Top!) }<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetBottom() { ReturnMethod(m_Bottom!) }<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Operator (override the CInteger operator)<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator=(CFraction newVal)<br><br>

&nbsp;&nbsp; private:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //Helper data<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Top!<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Bottom!<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Val!<br>
}<br><br>

//CFraction constructor<br>
Method CFraction::CFraction(top!, bottom!)<br>
{<br>
&nbsp;&nbsp; m_Top! = top!<br>
&nbsp;&nbsp; m_Bottom! = bottom!<br>
&nbsp;&nbsp; m_Val! = m_Top! / m_Bottom!<br>
}<br><br>

//CFraction operator=<br>
Method CFraction::operator=(CFraction newVal)<br>
{<br>
&nbsp;&nbsp; m_Top! = newVal->GetTop()<br>
&nbsp;&nbsp; m_Bottom! = newVal->GetBottom()<br>
&nbsp;&nbsp; m_Val! = m_Top! / m_Bottom!<br>
}</div><br>

<div class="BoxedText">At this time, you've learned a lot you can do with classes. Let's pause for a moment and look at some of the goals of using classes.<br><br>

One major goal you should try to follow is that each class has it's own purpose. Each class should be used for a single task, and should perform that task efficiently. Example: a string class should allow you to operate on a string; a person class should allow you to get information about a person; and a number class should allow you to do basic number manipulation.<br><br>

However, classes can form relationships between each other, as already shown, to extend the functionality of performing a task (example: the CInteger class inheriting (forming a relationship with) the CFraction class). The CFraction classes task is to perform a fraction, and the CInteger classes task is to store a number. Initially, these are two separate tasks. Since they relate to each other (they both deal specifically with numbers), one inheriting the other does not make it a class with more than one purpose. Instead, it combines the purposes. It doesn't just store a number, or just return a fraction, it is now used for storing and manipulating numbers.<br><br>

This is not always the case, though. As you might have guessed, one class inheriting another, when they have little or nothing in common, is a bad idea. This creates a class with multiple tasks. And a class with multiple tasks is much harder to write and use efficiently.</div><br><br><br>



<a name="spc.reference"></a>
<div class="MinorHeader">References and 'this'</div><br>
<div class="Normal">References are a very powerful tool. They allow you to use methods to create a synonym for data (making the method 'reference' the data). References must be returned from inside a method, and are created by using the & operator (you can call this the 'reference operator'), followed by a variable or object name (which will be the reference to the data). This makes the following possible:</div><br>

<div class="Code">
Method SomeString()<br>
{<br>
&nbsp;&nbsp; ReturnMethod(&rString$)<br>
}<br><br>

SomeString() = "Hello, world!"<br>
Show(SomeString()) //Output: "Hello, world!"</div><br>

Why is this so useful, though? The above example doesn't show any good use of references - only that they are returned from methods. However, you can think of more interesting, useful things to do with them. An example would be creating an array class. This is a good place to start, because arrays in RPGCode are limited, as they don't have upper-boundaries (so it's impossible to always know how high the index of an array goes if you, for example, Split() user input from a Prompt()). Here's an array class, using references:</div><br>

<div class="Code">
//////////////////////////////////////////////////<br>
// CArray class declaration<br>
//////////////////////////////////////////////////<br>
class CArray<br>
{<br>
&nbsp;&nbsp; public:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; // Constructor, destructor<br>
&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method CArray(bound!)<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method ~CArray()<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; // Operator []<br>
&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method operator[](index!)<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; // Member methods<br>
&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; Method GetBound() { ReturnMethod(m_Bound!) }<br><br>

&nbsp;&nbsp; private:<br><br>

&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; // Helper data<br>
&nbsp;&nbsp; &nbsp;&nbsp; //////////////////////////////////////////<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Bound!<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Data[]<br>
}<br><br>

//////////////////////////////////////////////////<br>
// Constructor<br>
//////////////////////////////////////////////////<br>
Method CArray::CArray(bound!)<br>
{<br>
&nbsp;&nbsp; If(bound! &#62;= 0)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; m_Bound! = bound!<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Else<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; Debugger("Array index is out of bounds: " + CastLit(bound!))<br>
&nbsp;&nbsp; }<br>
}<br><br>

//////////////////////////////////////////////////<br>
// Destructor<br>
//////////////////////////////////////////////////<br>
Method CArray::~CArray()<br>
{<br>
&nbsp;&nbsp; On Error Resume Next<br>
&nbsp;&nbsp; For(idx! = 0; idx! <= m_Bound!; idx!++)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; this[idx!]->release()<br>
&nbsp;&nbsp; &nbsp;&nbsp; Kill(this[idx!]!)<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Kill(idx!)<br>
}<br><br>

//////////////////////////////////////////////////<br>
// Operator []<br>
//////////////////////////////////////////////////<br>
Method CArray::operator[](index!)<br>
{<br>
&nbsp;&nbsp; //Check the bound<br>
&nbsp;&nbsp; If(index! <= m_Bound! && index! >= 0)<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; //In bounds. Return the data.<br>
&nbsp;&nbsp; &nbsp;&nbsp; ReturnMethod(&m_Data[index!])<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; Else<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp; //Out of bounds. Return null (0)<br>
&nbsp;&nbsp; &nbsp;&nbsp; Debugger("Array index is out of bounds: " + CastLit(index!))<br>
&nbsp;&nbsp; &nbsp;&nbsp; null! = 0<br>
&nbsp;&nbsp; &nbsp;&nbsp; ReturnMethod(&null!)<br>
&nbsp;&nbsp; }<br>
}<br><br>

//Create an array with a set upper-bound...<br>
strArray = CArray(2)<br><br>

//Put some data into the array<br>
strArray[0] = String("Hello, world!")<br>
strArray[1] = String("This is an example of an array class.")<br>
strArray[2] = String("Goodbye!")<br><br>

//Show the data<br>
For(i! = 0; i! <= strArray->GetBound(); i!++)<br>
{<br>
&nbsp;&nbsp; Show(strArray[i!])<br>
}<br><br>

Wait()<br><br>

//Release() the array...<br>
strArray->Release()</div><br>

<div class="Normal">Now we have a simple array class. Some of that might not make much sense, so I'll explain it. First, we run through the normal declarations; the class, constructor/destructor, methods, and data. The operator we're using here is the [] operator, which you use with normal arrays. When you overload the [] operator, it takes one parameter (the index).<br><br>

The constructor takes one parameter (bound!). The bound! is the upper-bound of the array, counting from 0 up (0, 1, 2, etc.). The constructor first checks to see if the bound you specify is greater than or equal to 0. If it is, the bound is stored in m_Bound!.<br><br>

Skipping ahead (we'll discuss the destructor in a moment), you have the overloaded operator method. Again, it only takes one parameter - index!. The index! is the index of the array to access. First, we check the bounds. If you specified an index higher than the upper-bound, or less than 0, it returns null (or 0). If everything checks out all right, it returns a reference to an object (&m_Data[index!]). If you look at the class declaration (in private:), you'll see the m_Data[] data member. This is an object-array that doesn't have a set bound.<br><br>

So why do we need to return a reference? Simply put, it would be impossible to make this class without returning references. You might be asking 'why?'. Well, let's take a look at the first example:</div><br>

<div class="Code">
Method SomeString()<br>
{<br>
&nbsp;&nbsp; ReturnMethod(&rString$)<br>
}<br><br>

SomeString() = "Hello, world!"<br>
Show(SomeString()) //Output: "Hello, world!"</div><br>

<div class="Normal">The returned reference allows you to do this: 'SomeString() = "Hello, world!"'. As such, it allows you to do this with the array class: 'strArray[0] = New(String, "Hello, world!")'. See? When you used the overloaded operator in the class (which returns the reference), it forced strArray[0] to become a reference for "Hello, world!". If you still don't understand completely, read over it a few times. It'll start making sense once you examine it.<br><br>

Now, you should notice that I don't need to call Release() for each array - only for the original strArray object itself. Take a look at the destructor. As you can see, it looks through every index, from 0 to m_Bound!. It's calling the Release() method from this[idx!]. What is 'this'? Well, every class has 'this' (much like it has a Release() method).<br><br>

'this' is the current object. When you see 'this[idx!]', it's 'this' calling the overloaded [] operator, and it's getting rid of it's contents. 'this[idx!]!' is a number representing this.</div><br><br><br>



<a name="spc.virtual"></a>
<div class="MinorHeader">Pure Virtual Methods</div><br>
<div class="Normal">When using classes, you might find yourself creating hierarchies (groups) of classes. An example would be a Shape class. From that Shape class, you could derive (inherit) a rectangle class, and a circle class. All of these classes would inherit a draw() method from the Shape class. This would be a good place to use pure virtual methods.<br><br>

What is a pure virtual method? It's a method that has no implementation (you supply no code for it in the class it originates from), but it has to have it's own implementation (code) for each class that derives (inherits) from the class containing the virtual method. That, and you cannot make objects of any classes that have pure virtual methods.<br><br>

Well, if you can't create objects from classes with pure virtual methods, what's the use of having them? A class that has pure virtual methods is considered to be an "abstract" class (or "abstract data type"). Abstract classes are thought of as concepts, more than objects. For example, I said earlier that you can create a Shape class with Rectangle and Circle classes deriving from it. Since a shape is more of a concept than an object, you wouldn't want the user of the class to create a Shape object (since it only has a draw() method).<br><br>

Here's an example of pure virtual methods:</div><br>

<div class="Code"><pre>//Create the Shape class
class Shape
{
   public:

      //The pure virtual method, draw()
      Method Draw() = 0
}

//Create the CRectangle class
class CRectangle: Shape
{
   public:

      //Constructor
      Method CRectangle(x!, y!, x2!, y2!)
      {
         m_X! = x!
         m_Y! = y!
         m_X2! = x2!
         m_Y2! = y2!
      }

      //Draw() method
      Method Draw()
      {
         DrawRect(m_X!, m_Y!, m_X2!, m_Y2!)
      }

   private:

      //private data
      m_X!
      m_Y!
      m_X2!
      m_Y2!
}

//Create the CCircle class
class CCircle: Shape
{
   public:

      //Constructor
      Method CCircle(x!, y!, radius!)
      {
         m_X! = x!
         m_Y! = y!
         m_Radius! = radius!
      }

      //Draw() method
      Method Draw()
      {
         DrawCircle(m_X!, m_Y!, m_Radius!)
      }

   private:

      //private data
      m_X!
      m_Y!
      m_Radius!
}

//Draw some shapes...
circle = CCircle(100, 250, 100)
square = CRectangle(300, 200, 400, 300)
circle->Draw()
square->Draw()

//Release the data
circle->Release()
square->Release()</pre></div><br>

<div class="Normal">You'll probably notice what's different about the pure virtual method. It has a "= 0" after it. Initializing methods as 0 means that they are pure virtual methods. Both the CRectangle and CCircle classes inherit the Shape class, so both of the derived classes must include an implementation (code) for the inherited pure virtual methods. So, as you can see, there are plenty of reasons to use pure virtual methods.</div><br><br><br>



<a name="reserved"></a>
<div class="MajorHeader">Reserved Variables</div><br>
<div class="Normal">There are a number of variables that the Toolkit automatically creates when you play your game. They are as follows:<br><br>

<b>playerHandle[x!]!</b> - the handles of the players on your team that you specified in the character editor. x! is a value between 0 and 4. 0 being the first character on your team, 1 being the second, etc..<br><br>

<b>playerX[x!]!</b> - the x! coordinate of the players on your team. x! is a value between 0 and 4.<br><br>

<b>playerY[x!]!</b> - the y! coordinate of the players on your team. y! is a value between 0 and 4.<br><br>

<b>playerLayer[x!]!</b> - the layer that your players are currently on. x! is a value between 0 and 4.<br><br>

<b>boardTitle[x!]$</b> - the titles of the 8 layers of a board. x! is a value between 1 and 8.<br><br>

<b>constant[x!]!</b> - the 11 board constants set in the board editor. x! is a value between 0 and 10.<br><br>

<b>boardBackground$</b> - the fighting background of the current board.<br><br>

<b>boardSkill!</b> - the fighting skill of the enemies on the current board.<br><br>

<b>threads[pos!]!</b> - stores the ID's of the threads used on a board.<br><br>

<b>cnvRenderNow!</b> - this is the ID of a canvas that can be constantly rendered to the screen using the RenderNow() command.<br><br>

<b>ambientRed!, ambientGreen!, ambientBlue!</b> - the ambient colors of the boards in your game. You can adjust their values. Accepted values are from -255 to 255.<br><br>

<b>music$</b> - the filename of the music that is playing on the current board.<br><br>

<b>gametime!</b> - the total game time in seconds.<br><br>

You can't edit any of these variables except the ambient variables. You can, however, access these variables just like any other global variable. To update the reserved variables in a program, use the SetConstants() command.</div><br><br><br>



<a name="reserved.target"></a>
<div class="MinorHeader">Target and Source Handles:</div><br>
<div class="Normal">There are two special handles named "Target" and "Source". These refer to the currently selected player, item or enemy. For example, if a program was being run from the internal menu and the user clicked on a player, you could get that player's HP by using:</div><br>

<div class="Code">
	GetHP("target", hp!)</div><br>

<div class="Normal">In this case, instead of using the player's actual handle, "Target" produced the correct result. This can also be used to push the target item around to create walking villagers, etc. All commands that can use "Target" as their handle are explained in the Command Reference section.<br><br>

"Source" is used in fights. Source refers to the player or enemy who is currently performing a battle move. Target is the player or enemy targeted by the move. Source can be used wherever Target is used.</div><br>